[{"id":"c0524bc960f43aa892c6edbb08789fd2","title":"LeetCode第107题：二叉树的层序遍历 II","content":"107.二叉树的层序遍历 II题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n树,BFS\nYes\n\n\n题目要求给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）。\n示例示例1.\n输入：root = [3,9,20,null,null,15,7]\n输出：[[15,7],[9,20],[3]]\n\n解题思路\n利用树的BFS模板，得到结果列表反转即可\n\n代码参考class Solution:\n    def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]:\n        if not root:\n            return []\n        temp_res &#x3D; [root]\n        res &#x3D; []\n        while temp_res:\n            res.append([i.val for i in temp_res])\n            next_level &#x3D; []\n            for i in temp_res:\n                if i.left:\n                    next_level.append(i.left)\n                if i.right:\n                    next_level.append(i.right)\n            temp_res &#x3D; next_level\n\t\t# 以上为树的广度搜索的模板\n        res.reverse()\n        return res\n\n","slug":"LeetCode第107题：二叉树的层序遍历 II","date":"2022-09-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,树,BFS,Like","author_index":"秋水"},{"id":"2e71333626c3011cee190883801aa78f","title":"LeetCode第237题：删除链表中的节点","content":"237.删除链表中的节点题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n链表\nNo\n\n\n题目要求请编写一个函数，用于 删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问 要被删除的节点 。\n题目数据保证需要删除的节点 不是末尾节点 。\n示例示例1.\n输入：head = [4,5,1,9], node = 5\n输出：[4,1,9]\n解释：指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9\n\n示例2.\n输入：head = [4,5,1,9], node = 1\n输出：[4,5,9]\n解释：指定链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9\n\n解题思路\n由于我们不无法获取链表的头，所以编写函数需返回任何值\n我们无法获取头，也就是说我们无法对要删除的链表的前驱进行操作\n我们只需要将要删除的节点的后继的值覆盖删除节点的值\n然后将链表的倒数二个节点的后继置空，就完成了删除节点的操作\n\n代码参考#\n# @lc app&#x3D;leetcode.cn id&#x3D;237 lang&#x3D;python3\n#\n# [237] 删除链表中的节点\n#\n\n# @lc code&#x3D;start\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val &#x3D; x\n#         self.next &#x3D; None\n\nclass Solution:\n\tdef deleteNode(self, node):\n\t\t&quot;&quot;&quot;\n\t\t:type node: ListNode\n\t\t:rtype: void Do not return anything, modify node in-place instead.\n\t\t&quot;&quot;&quot;\n\t\tnode1 &#x3D; node\n\t\twhile node.next:\n\t\t\tnode.val &#x3D; node.next.val\n\t\t\tif node.next.next:\n\t\t\t\tnode &#x3D; node.next\n\t\t\telse:\n\t\t\t\tnode.next &#x3D; None\n# @lc code&#x3D;end\n\n","slug":"LeetCode第237题：删除链表中的节点","date":"2022-09-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,链表","author_index":"秋水"},{"id":"3f9b149edda744a0462c85c999c4b231","title":"LeetCode第1441题：用栈操作构建数组","content":"1441.用栈操作构建数组题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n栈,模拟\nNo\n\n\n题目要求给你一个数组 target 和一个整数 n。每次迭代，需要从  list = [1, 2, 3,..., n]中依次读取一个数字。请使用下述操作来构建目标数组 target ：\n\n&quot;Push&quot;：从 list 中读取一个新元素， 并将其推入数组中。\n&quot;Pop&quot;：删除数组中的最后一个元素。\n如果目标数组构建完成，就停止读取更多元素。\n\n题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。请返回构建目标数组所用的操作序列。如果存在多个可行方案，返回任一即可。\n示例示例1.\n输入：target = [1,3], n = 3\n输出：[&quot;Push&quot;,&quot;Push&quot;,&quot;Pop&quot;,&quot;Push&quot;]\n解释： \n读取 1 并自动推入数组 -&gt; [1]\n读取 2 并自动推入数组，然后删除它 -&gt; [1]\n读取 3 并自动推入数组 -&gt; [1,3]\n\n示例2.\n输入：target = [1,2,3], n = 3\n输出：[&quot;Push&quot;,&quot;Push&quot;,&quot;Push&quot;]\n\n示例3.\n**输入：**target = [1,2], n = 4\n**输出：**[&quot;Push&quot;,&quot;Push&quot;]\n**解释：**只需要读取前 2 个数字就可以停止。\n\n解题思路\n将target以字典形式存储，减少查找时间\n如果1-n中含target只需入栈“Push”即可，若不存在则先入“Push”再入“Pop”\n最后若max(target) &lt; n的话只用判断到target最大的值即可终止循环\n\n代码参考class Solution:\n\tdef buildArray(self, target: List[int], n: int) -&gt; List[str]:\n\t\ttar &#x3D; set(target)\n\t\tres &#x3D; []\n\t\tfor i in range(1, max(tar) + 1):\n\t\t\tres.append(&#39;Push&#39;)\n\t\t\tif i in tar:\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tres.append(&#39;Pop&#39;)\n\t\treturn res\n\n","slug":"LeetCode第1441题：用栈操作构建数组","date":"2022-09-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,栈,模拟","author_index":"秋水"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-10-15T02:41:39.690Z","categories_index":"","tags_index":"","author_index":"秋水"},{"id":"91986e7de18a1f0d056c15eb6d3ad084","title":"LeetCode第575题：分糖果","content":"1441.用栈操作构建数组题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEesy\n脑筋急转弯\nNo\n\n\n题目要求 Alice 有 n 枚糖，其中第 i 枚糖的类型为 candyType[i] 。Alice 注意到她的体重正在增长，所以前去拜访了一位医生。\n医生建议 Alice 要少摄入糖分，只吃掉她所有糖的 n / 2 即可（n 是一个偶数）。Alice 非常喜欢这些糖，她想要在遵循医生建议的情况下，尽可能吃到最多不同种类的糖。\n给你一个长度为 n 的整数数组 candyType ，返回： Alice 在仅吃掉 n / 2 枚糖的情况下，可以吃到糖的最多种类数。\n示例示例1.\n输入：candyType = [1,1,2,2,3,3]\n输出：3\n解释：Alice 只能吃 6 / 2 = 3 枚糖，由于只有 3 种糖，她可以每种吃一枚。\n\n示例2.\n输入：candyType = [1,1,2,3]\n输出：2\n解释：Alice 只能吃 4 / 2 = 2 枚糖，不管她选择吃的种类是 [1,2]、[1,3] 还是 [2,3]，她只能吃到两种不同类的糖。\n\n示例3.\n输入：candyType = [6,6,6,6]\n输出：1\n解释：Alice 只能吃 4 / 2 = 2 枚糖，尽管她能吃 2 枚，但只能吃到 1 种糖。\n\n解题思路\n只需考虑两张极端思路即可得出答案\nAlice最多能吃len(candyType)的一半或者元素都相同则怎么吃都是一种\n最后只需判断是是candyType的长度一半大还是candyType的字典长度大即可\n\n代码参考class Solution:\n    def distributeCandies(self, candyType: List[int]) -&gt; int:\n        return len(candyType) &#x2F;&#x2F; 2 if len(set(candyType)) &gt; len(candyType) &#x2F;&#x2F; 2 else len(set(candyType))\n\n","slug":"LeetCode第575题：分糖果","date":"2022-09-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,脑筋急转弯","author_index":"秋水"},{"id":"cecf4faf8156d8be7b73bb8270261e34","title":"LeetCode第64题：最小路径和","content":"107.二叉树的层序遍历 II题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n动态规划\nYes\n\n\n题目要求给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n说明：每次只能向下或者向右移动一步。\n示例示例1.\n输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\n输出：7\n解释：因为路径 1→3→1→1→1 的总和最小。\n\n解题思路\n这种步步要精打细算很容易想到要求贪心算法或者动态规划\n但是贪心算法可能陷入局部最优所以采用动态规划\n先计算边缘格子的移动Cost，然后再利用双重循环的最小Cost来判断是往右还是往下走\n\n代码参考class Solution:\n    def minPathSum(self, grid: List[List[int]]) -&gt; int:\n        m, n &#x3D; len(grid), len(grid[0])\n        dp &#x3D; [[0] * n for _ in range(m)]\n        dp[0][0] &#x3D; grid[0][0]\n        for i in range(1, m):\n            dp[i][0] &#x3D; dp[i-1][0] + grid[i][0]\n        for j in range(1, n):\n            dp[0][j] &#x3D; dp[0][j-1] + grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] &#x3D; min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        return dp[m-1][n-1]\n\n","slug":"LeetCode第64题：最小路径和","date":"2022-09-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,动态规划","author_index":"秋水"},{"id":"21e1d52c3b2ce6bf6d44dddedefce323","title":"LeetCode第61题：旋转链表","content":"61.旋转链表题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n链表\nYes\n\n\n题目要求给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\n示例示例1.\n输入：head = [1,2,3,4,5], k = 2\n输出：[4,5,1,2,3]\n\n示例2.\n输入：head = [0,1,2], k = 4\n输出：[2,0,1]\n\n解题思路\n这种旋转的思路都大致相同，将两个相同的链表连接，然后再减去多余步数，即使答案\n例如示例二可变为：0-&gt;1-&gt;2-&gt;0-&gt;1-&gt;2，然后4是大于自身3的长度即用k去取余长度即使真正的步数，真正的步数永远不会大于两倍的lenght，所以只要在遍历一遍然后用长度减去真正的步数即使答案所求链表\n\n代码参考# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val&#x3D;0, next&#x3D;None):\n#         self.val &#x3D; val\n#         self.next &#x3D; next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:\n        if not head or not head.next or k &#x3D;&#x3D; 0:\n            return head\n        node &#x3D; ListNode(0)\n        node.next &#x3D; head\n        p1 &#x3D; node\n        lenght &#x3D; 0\n        while p1.next:\n            lenght +&#x3D; 1\n            p1 &#x3D; p1.next\n        if k % lenght &#x3D;&#x3D; 0:\n            return head\n        p1.next &#x3D; head\n        p1 &#x3D; node\n        i &#x3D; lenght - (k % lenght)\n        while i:\n            p1 &#x3D; p1.next\n            i -&#x3D; 1\n        result &#x3D; ListNode(0)\n        result.next &#x3D; p1.next\n        p1.next &#x3D; None\n        return result.next\n\n","slug":"LeetCode第61题：旋转链表","date":"2022-09-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,链表,Like","author_index":"秋水"}]