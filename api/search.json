[{"id":"3c1df83d6c4d033a66322b21ef2ea886","title":"LeetCode第2376题：统计特殊整数","content":"2376.统计特殊整数题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nHard\n数位dp\nYes\n\n\n题目要求如果一个正整数每一个数位都是 互不相同 的，我们称它是 特殊整数 。给你一个 正 整数 n ，请你返回区间 [1, n] 之间特殊整数的数目。\n示例示例1.\n输入：n = 20\n输出：19\n解释：1 到 20 之间所有整数除了 11 以外都是特殊整数。所以总共有 19 个特殊整数。\n\n示例2.\n输入：n = 5\n输出：5\n解释：1 到 5 所有整数都是特殊整数。 \n\n示例3.\n输入：n = 135\n输出：110\n解释：从 1 到 135 总共有 110 个整数是特殊整数。\n不特殊的部分数字为：22 ，114 和 131 。\n\n解题思路\n使用模板（还在施工\n\n代码参考class Solution:\n    def countSpecialNumbers(self, n: int) -&gt; int:\n        # 数位DP模板\n        s &#x3D; str(n)\n        \n        @lru_cache\n        def f(i: int, mask: int, is_limit: bool, is_num: bool) -&gt; int:\n            if i &#x3D;&#x3D; len(s):\n                return int(is_num)\n            res &#x3D; 0\n            if not is_num: # 选择跳过\n                res &#x3D; f(i + 1, mask, False, False)\n            up &#x3D; int(s[i]) if is_limit else 9\n            # 枚举要填的数字，枚举范围取决于is_limit和is_num\n            for d in range(1 - int(is_num), up + 1):\n                if mask &gt;&gt; d &amp; 1 &#x3D;&#x3D; 0: #mask里没有d\n                    res +&#x3D; f(i + 1, mask | (1 &lt;&lt; d), is_limit and d &#x3D;&#x3D; up, True)\n            return res\n        return f(0, 0, True, False)\n\n","slug":"LeetCode第2376题：统计特殊整数","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,动态规划,数位dp,Like","author_index":"秋水"},{"id":"d14c45a1dbcb2674b71ebe2ea419cd16","title":"LeetCode第2375题：根据模式串构建最小数字","content":"2375.根据模式串构建最小数字题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n数位dp\nYes\n\n\n题目要求给你下标从 0 开始、长度为 n 的字符串 pattern ，它包含两种字符，&#39;I&#39; 表示 上升 ，&#39;D&#39; 表示 下降 。\n你需要构造一个下标从 0 开始长度为 n + 1 的字符串，且它要满足以下条件：\n\nnum 包含数字 &#39;1&#39; 到 &#39;9&#39; ，其中每个数字 至多 使用一次。\n如果 pattern[i] == &#39;I&#39; ，那么 num[i] &lt; num[i + 1] 。\n如果 pattern[i] == &#39;D&#39; ，那么 num[i] &gt; num[i + 1] 。\n\n你返回满足上述条件字典序 最小 的字符串 num。\n示例示例1.\n输入：pattern = &quot;IIIDIDDD&quot;\n输出：&quot;123549876&quot;\n解释：\n下标 0 ，1 ，2 和 4 处，我们需要使 num[i] &lt; num[i+1] 。\n下标 3 ，5 ，6 和 7 处，我们需要使 num[i] &gt; num[i+1] 。\n一些可能的 num 的值为 &quot;245639871&quot; ，&quot;135749862&quot; 和 &quot;123849765&quot; 。\n&quot;123549876&quot; 是满足条件最小的数字。\n注意，&quot;123414321&quot; 不是可行解因为数字 &#39;1&#39; 使用次数超过 1 次。\n\n示例2.\n输入：n = 5\n输出：5\n解释：1 到 5 所有整数都是特殊整数。 \n\n示例3.\n输入：pattern = &quot;DDD&quot;\n输出：&quot;4321&quot;\n解释：\n一些可能的 num 的值为 &quot;9876&quot; ，&quot;7321&quot; 和 &quot;8742&quot; 。\n&quot;4321&quot; 是满足条件最小的数字。\n\n解题思路\n先建立一个1到pattern长度加一的字符串，其值为:\n[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, ..., &#39;len(pattern) + 1&#39;]\n观察答案知只需要把模式串中的D的下标与其下标加一的切边给倒转即可\n\n代码参考class Solution:\n    def smallestNumber(self, pattern: str) -&gt; str:\n        n &#x3D; len(pattern)\n        res &#x3D; list(digits[1: n + 2])\n        i &#x3D; 0\n        while i &lt; n:\n            if pattern[i] &#x3D;&#x3D; &#39;I&#39;:\n                i +&#x3D; 1\n                continue\n            st &#x3D; i\n            i +&#x3D; 1\n            while i &lt; n and pattern[i] &#x3D;&#x3D; &#39;D&#39;:\n                i +&#x3D; 1\n            res[st: i + 1] &#x3D; res[st: i + 1][::-1]\n        return &#39;&#39;.join(res)\n\n","slug":"LeetCode第2375题：根据模式串构建最小数字","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,贪心","author_index":"秋水"},{"id":"2f29bc9f36642c684480423dd6e71762","title":"LeetCode第1012题：至少有1为重复的数字","content":"1012.至少有1为重复的数字题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nHard\n数位dp\nYes\n\n\n题目要求给定正整数 n，返回在 [1, n] 范围内具有 至少 1 位 重复数字的正整数的个数。\n示例示例1.\n输入：n = 20\n输出：1\n解释：具有至少 1 位重复数字的正数（&lt;= 20）只有 11 。\n\n示例2.\n输入：n = 100\n输出：10\n解释：具有至少 1 位重复数字的正数（&lt;= 100）有 11，22，33，44，55，66，77，88，99 和 100 \n\n示例3.\n输入：n = 1000\n输出：262\n\n解题思路\n使用模板（还在施工\n\n代码参考class Solution:\n    def numDupDigitsAtMostN(self, n: int) -&gt; int:\n        # 数位DP模板\n        s &#x3D; str(n)\n        \n        @lru_cache\n        def f(i: int, mask: int, is_limit: bool, is_num: bool) -&gt; int:\n            if i &#x3D;&#x3D; len(s):\n                return int(is_num)\n            res &#x3D; 0\n            if not is_num: # 选择跳过\n                res &#x3D; f(i + 1, mask, False, False)\n            up &#x3D; int(s[i]) if is_limit else 9\n            # 枚举要填的数字，枚举范围取决于is_limit和is_num\n            for d in range(1 - int(is_num), up + 1):\n                if mask &gt;&gt; d &amp; 1 &#x3D;&#x3D; 0: #mask里没有d\n                    res +&#x3D; f(i + 1, mask | (1 &lt;&lt; d), is_limit and d &#x3D;&#x3D; up, True)\n            return res\n        return n - f(0, 0, True, False)\n\n","slug":"LeetCode第1012题：至少有1为重复的数字","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,动态规划,数位dp,Like","author_index":"秋水"},{"id":"c02a0d58d02f45cdce74135318840401","title":"LeetCode第2374题：边积分最高的节点","content":"2374.边积分最高的节点题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n数组\nNo\n\n\n题目要求给你一个有向图，图中有 n 个节点，节点编号从 0 到 n - 1 ，其中每个节点都 恰有一条 出边。\n图由一个下标从 0 开始、长度为 n 的整数数组 edges 表示，其中 edges[i] 表示存在一条从节点 i 到节点 edges[i] 的 有向 边。\n节点 i 的 边积分 定义为：所有存在一条指向节点 i 的边的节点的 编号 总和。\n返回 边积分 最高的节点。如果多个节点的 边积分 相同，返回编号 最小 的那个。\n示例示例1.\n输入：edges = [1,0,0,0,0,7,7,5]\n输出：7\n解释：\n- 节点 1、2、3 和 4 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 + 3 + 4 = 10 。\n- 节点 0 有一条指向节点 1 的边，节点 1 的边积分等于 0 。\n- 节点 7 有一条指向节点 5 的边，节点 5 的边积分等于 7 。\n- 节点 5 和 6 都有指向节点 7 的边，节点 7 的边积分等于 5 + 6 = 11 。\n节点 7 的边积分最高，所以返回 7 。\n\n示例2.\n输入：edges = [2,0,0,2]\n输出：0\n解释：\n- 节点 1 和 2 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 = 3 。\n- 节点 0 和 3 都有指向节点 2 的边，节点 2 的边积分等于 0 + 3 = 3 。\n节点 0 和 2 的边积分都是 3 。由于节点 0 的编号更小，返回 0 。\n\n解题思路\n读懂题目，遍历边数组时同时遍历下标和值，因为最后查找时是按下标顺序，所以必然是索引值的最小值\n\n代码参考class Solution:\n    def edgeScore(self, edges: List[int]) -&gt; int:\n        tmp &#x3D; [0] * len(edges)\n        res &#x3D; 0\n        for i, j in enumerate(edges):\n            tmp[j] +&#x3D; i\n            if tmp[j] &gt; tmp[res] or (tmp[j] &#x3D;&#x3D; tmp[res] and j &lt; res):\n                res &#x3D; j\n        return res\n\n","slug":"LeetCode第2374题：边积分最高的节点","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,数组","author_index":"秋水"},{"id":"9eb1bd5b03774bfeca70051c02665fcc","title":"LeetCode第2373题：矩阵局部最大值","content":"2373.矩阵局部最大值题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n矩阵\nNo\n\n\n题目要求给你一个大小为 n x n 的整数矩阵 grid 。\n生成一个大小为 (n - 2) x (n - 2) 的整数矩阵  maxLocal ，并满足：\n\nmaxLocal[i][j] 等于 grid 中以 i + 1 行和 j + 1 列为中心的 3 x 3 矩阵中的 最大值 。换句话说，我们希望找出 grid 中每个 3 x 3 矩阵中的最大值。\n\n返回生成的矩阵。\n示例示例1.\n输入：grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]\n输出：[[9,9],[8,6]]\n解释：原矩阵和生成的矩阵如上图所示。\n注意，生成的矩阵中，每个值都对应 grid 中一个相接的 3 x 3 矩阵的最大值。\n\n示例2.\n输入：grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]\n输出：[[2,2,2],[2,2,2],[2,2,2]]\n解释：注意，2 包含在 grid 中每个 3 x 3 的矩阵中。\n\n解题思路\n用双重循环来判断每三行每三列的最大值，然后存储到左上角，这部分区域再也不会用到\n使用pop来保证最后返回的矩阵规格合法且省去切片是copy的时间\n\n代码参考class Solution:\n    def largestLocal(self, grid: List[List[int]]) -&gt; List[List[int]]:\n        n &#x3D; len(grid)\n        for i in range(n - 2):\n            for j in range(n - 2):\n                grid[i][j] &#x3D; max(max(row[j: j + 3]) for row in grid[i: i + 3])\n            grid[i].pop()\n            grid[i].pop()\n        grid.pop()\n        grid.pop()\n        return grid\n\n","slug":"LeetCode第2373题：矩阵局部最大值","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,矩阵","author_index":"秋水"},{"id":"18ba4601c07e45b1b8afaa7828c586ff","title":"LeetCode第x题：x","content":"2376.统计特殊整数题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n栈，模拟\nNo\n\n\n题目要求学校的自助午餐提供圆形和方形的三明治，分别用数字 0 和 1 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。\n餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 栈 里，每一轮：\n\n如果队列最前面的学生 喜欢 栈顶的三明治，那么会 拿走它 并离开队列。\n否则，这名学生会 放弃这个三明治 并回到队列的尾部。\n\n这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。\n给你两个整数数组 students 和 sandwiches，其中 sandwiches[i] 是栈里面第 i 个三明治的类型（i = 0 是栈的顶部）， students[j] 是初始队。列里第 j 名学生对三明治的喜好（j = 0 是队列的最开始位置）。请你返回无法吃午餐的学生数量。\n示例示例1.\n输入：students = [1,1,0,0], sandwiches = [0,1,0,1]\n输出：0 \n解释：\n- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [1,0,0,1]。\n- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [0,0,1,1]。\n- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [0,1,1]，三明治栈为 sandwiches = [1,0,1]。\n- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [1,1,0]。\n- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [1,0]，三明治栈为 sandwiches = [0,1]。\n- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [0,1]。\n- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [1]，三明治栈为 sandwiches = [1]。\n- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = []，三明治栈为 sandwiches = []。\n所以所有学生都有三明治吃。\n\n示例2.\n输入：students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]\n输出：3 \n\n解题思路\n读懂题意进行模拟即可，第一个if判断如果只有一种学生但是有多种三明治，则直接退出循环，因为再学生为[1, 1, 1]但三明治为[0, 1, 1]时怎么排队都无法拿去第一个三明治\n第二个if模拟排队过程，出栈底元素再将他入栈，最后一个判断是当匹配条件的时候，学生拿走三明治然后计数加一\n最后返回长度减去计数即可，若是第一个学生和第一个三明治匹配就返回长度减去计数再减一，防止只剩最后一个学生没判断上\n\n代码参考class Solution:\n    def countStudents(self, students: List[int], sandwiches: List[int]) -&gt; int:\n        length &#x3D; len(students)\n        count &#x3D; 0\n        while len(students) &gt; 1:\n            if len(set(students)) &#x3D;&#x3D; 1 and students[0] !&#x3D; sandwiches[0]:\n                break\n            if students[0] !&#x3D; sandwiches[0]:\n                students.append(students.pop(0))\n                continue\n            else:\n                students.pop(0)\n                sandwiches.pop(0)\n                count +&#x3D; 1\n        return length - count if students[0] !&#x3D; sandwiches[0] else length - count - 1\n\n","slug":"LeetCode第1700题：无法吃午餐的学生数量","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,栈,模拟","author_index":"秋水"},{"id":"889b01da9eb4b8005ed2590296364df0","title":"LeetCode第396题：旋转函数","content":"396.旋转函数题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n动态规划，数组\nYes\n\n\n题目要求给定一个长度为 n 的整数数组 nums 。\n假设 arrk 是数组 nums 顺时针旋转 k 个位置后的数组，我们定义 nums 的 旋转函数  F 为：\n\nF(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]\n\n返回 F(0), F(1), ..., F(n-1)中的最大值 。\n生成的测试用例让答案符合 32 位 整数。\n示例示例1.\n输入: nums = [4,3,2,6]\n输出: 26\n解释:\nF(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25\nF(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16\nF(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23\nF(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26\n所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26 。\n\n示例2.\n输入: nums = [100]\n输出: 0\n\n解题思路\n观察答案可知，我们先将F(0)求出存入数组，然后F(1)相当于加上了整个数组的和，再减去倒数i位的n倍，这个n为数组长度，即F(1) = F(0) + sum(nums) - len(nums) * nums[-1]\n\n代码参考class Solution:\n    def maxRotateFunction(self, nums: List[int]) -&gt; int:\n        if len(nums) &#x3D;&#x3D; 1:\n            return 0\n        s, n &#x3D; sum(nums), len(nums)\n        res &#x3D; [sum(idx * val for idx, val in enumerate(nums))]\n        for i in range(1, len(nums)):\n            res.append(res[i - 1] + s - n * nums[-i])\n        return max(res)","slug":"LeetCode第396题：旋转函数","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,动态规划,Like,数组","author_index":"秋水"},{"id":"abd31ef79b2cfb8b01bf4c9895fea23c","title":"LeetCode第33题：搜索旋转排序数组","content":"33.搜索旋转排序数组题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n二分查找\nYes\n\n\n题目要求整数数组 nums 按升序排列，数组中的值 互不相同 。\n在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1],..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1。\n你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\n示例示例1.\n输入：nums = [4,5,6,7,0,1,2], target = 0\n输出：4\n\n示例2.\n输入：nums = [4,5,6,7,0,1,2], target = 3\n输出：-1\n\n示例3.\n输入：nums = [1], target = 0\n输出：-1\n\n解题思路\n使用二分查找，因为二分查找时间复杂度为logn，但是要有序才能使用二分查找\n看题意可知此旋转的数组时一半一半有序，使用只需分左半边和右半边进行分类讨论\n\n代码参考class Solution:\n    def search(self, nums: List[int], target: int) -&gt; int:\n        l, r &#x3D; 0, len(nums) - 1\n        while l &lt;&#x3D; r:\n            mid &#x3D; (l + r) &#x2F;&#x2F; 2\n            if nums[mid] &#x3D;&#x3D; target:\n                return mid  \n            elif nums[l] &lt;&#x3D; nums[mid]:#左半边有序的情况\n                if target &gt;&#x3D; nums[l] and target &lt; nums[mid]:\n                    r &#x3D; mid - 1 #大了，右边界缩小\n                else:\n                    l &#x3D; mid + 1 #小了， 左边界放大\n            else:\n                if target &lt;&#x3D; nums[r] and target &gt; nums[mid]:#右半边有序的情况\n                    l &#x3D; mid + 1\n                else:\n                    r &#x3D; mid - 1\n        return -1\n\n","slug":"LeetCode第33题：搜索旋转排序数组","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,二分查找","author_index":"秋水"},{"id":"6bf19f9e1626f2ef77b3dc19b91f8698","title":"LeetCode第46题：旋转图像","content":"46.旋转图像题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n数组\nNo\n\n\n题目要求给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。\n你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。\n示例示例1.\n输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[[7,4,1],[8,5,2],[9,6,3]]\n\n示例2.\n输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n解题思路\n建立一个辅助数组进行交换，先取每列然后反转\n\n代码参考class Solution:\n    def rotate(self, matrix: List[List[int]]) -&gt; None:\n        &quot;&quot;&quot;\n        Do not return anything, modify matrix in-place instead.\n        &quot;&quot;&quot;\n        n &#x3D; len(matrix)\n        res &#x3D; [[] for _ in range(n)]\n        for i in range(n):\n            res[i] &#x3D; [matrix[j][i] for j in range(n)]\n        for i in range(len(matrix)):\n            matrix[i] &#x3D; res[i][::-1]\n","slug":"LeetCode第46题：旋转图像","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,数组","author_index":"秋水"},{"id":"b846fdcd170df4cd2690cf94865d978d","title":"LeetCode第33题：搜索旋转排序数组 II","content":"33.搜索旋转排序数组  II题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n二分查找\nYes\n\n\n题目要求整数数组 nums 按升序排列，数组中的值 互不相同 。\n在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1],..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回true，否则返回 false。\n你必须尽可能减少整个操作步骤。\n示例示例1.\n输入：nums = [2,5,6,0,0,1,2], target = 0\n输出：true\n\n示例2.\n输入：nums = [2,5,6,0,0,1,2], target = 3\n输出：false\n\n解题思路\n与33题类似，但是因为可能出现重复元素，使用当中间与前后两端的l，r对应的值相同时要l+1和r-1来缩小范围确定查找区间\n\n代码参考class Solution:\n    def search(self, nums: List[int], target: int) -&gt; bool:\n        l, r &#x3D; 0, len(nums) - 1\n        while l &lt;&#x3D; r:\n            mid &#x3D; (l + r) &#x2F;&#x2F; 2\n            if nums[mid] &#x3D;&#x3D; target:\n                return True  \n            if nums[mid] &#x3D;&#x3D; nums[l] &#x3D;&#x3D; nums[r]:\n                l +&#x3D; 1\n                r -&#x3D; 1\n            elif nums[l] &lt;&#x3D; nums[mid]:#左半边有序的情况\n                if target &gt;&#x3D; nums[l] and target &lt; nums[mid]:\n                    r &#x3D; mid - 1 #大了，右边界缩小\n                else:\n                    l &#x3D; mid + 1 #小了， 左边界放大\n            else:\n                if target &lt;&#x3D; nums[r] and target &gt; nums[mid]:#右半边有序的情况\n                    l &#x3D; mid + 1\n                else:\n                    r &#x3D; mid - 1\n        return False\n\n","slug":"LeetCode第81题：搜索旋转排序数组 II","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,二分查找","author_index":"秋水"},{"id":"c30798b33e66c8d20737c478b69704f2","title":"LeetCode第796题：旋转字符串","content":"796.旋转字符串题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n字符串\nNo\n\n\n题目要求给定两个字符串, s 和 goal。如果在若干次旋转操作之后，s 能变成 goal ，那么返回 true 。\ns 的 旋转操作 就是将 s 最左边的字符移动到最右边。\n\n例如, 若 s = &#39;abcde&#39;，在旋转一次之后结果就是&#39;bcdea&#39; 。\n\n示例示例1.\n输入: s = &quot;abcde&quot;, goal = &quot;cdeab&quot;\n输出: true\n\n示例2.\n输入: s = &quot;abcde&quot;, goal = &quot;abced&quot;\n输出: false \n\n解题思路\n将字符串首位拼接一次，即s*2，然后判断goal是否在这串中，若不在则必不能旋转成goal\n还要判断原串和目标串是否长度相同\n\n代码参考class Solution:\n    def rotateString(self, s: str, goal: str) -&gt; bool:\n        return True if goal in s*2 and len(goal) &#x3D;&#x3D; len(s) else False\n","slug":"LeetCode第796题：旋转字符串","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,字符串","author_index":"秋水"},{"id":"fa6eed31fec0f134d367ea17142dbc3e","title":"LeetCode第902题：最大为N的数字组合","content":"9902.最大为N的数字组合题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nHard\n数位dp\nYes\n\n\n题目要求给定一个按 非递减顺序 排列的数字数组digits。你可以用任意次数digits[i]来写的数字。例如，如果digits = [&#39;1&#39;,&#39;3&#39;,&#39;5&#39;]，我们可以写数字，如&#39;13&#39;, &#39;551&#39;, 和&#39;1351315&#39;。\n返回 可以生成的小于或等于给定整数 n 的正整数的个数 。\n示例示例1.\n输入：digits = [&quot;1&quot;,&quot;3&quot;,&quot;5&quot;,&quot;7&quot;], n = 100\n输出：20\n解释：\n可写出的 20 个数字是：\n1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.\n\n示例2.\n输入：digits = [&quot;1&quot;,&quot;4&quot;,&quot;9&quot;], n = 1000000000\n输出：29523\n解释：\n我们可以写 3 个一位数字，9 个两位数字，27 个三位数字，\n81 个四位数字，243 个五位数字，729 个六位数字，\n2187 个七位数字，6561 个八位数字和 19683 个九位数字。\n总共，可以使用D中的数字写出 29523 个整数。\n\n示例3.\n输入：digits = [&quot;7&quot;], n = 8\n输出：1\n\n解题思路\n使用模板（还在施工\n\n代码参考class Solution:\n    def atMostNGivenDigitSet(self, digits: List[str], n: int) -&gt; int:\n        s &#x3D; str(n)\n\n        @lru_cache\n        def f(i: int, is_limit: bool, is_num: bool) -&gt; int:\n            if i &#x3D;&#x3D; len(s):\n                return int(is_num)\n            res &#x3D; 0\n            if not is_num: # 选择跳过\n                res &#x3D; f(i + 1, False, False)\n            up &#x3D; s[i] if is_limit else &#39;9&#39;\n            # 枚举要填的数字，枚举范围取决于is_limit和is_num\n            for d in digits:\n                if d &gt; up: \n                    break #mask里没有d\n                res +&#x3D; f(i + 1, is_limit and d &#x3D;&#x3D; up, True)\n            return res\n        return f(0, True, False)\n\n","slug":"LeetCode第902题：最大为N的数字组合","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,动态规划,数位dp,Like","author_index":"秋水"},{"id":"18ba4601c07e45b1b8afaa7828c586ff","title":"LeetCode第x题：x","content":"2376.统计特殊整数题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nx\nx\nx\n\n\n题目要求示例示例1.\n输入：n = 20\n输出：19\n解释：1 到 20 之间所有整数除了 11 以外都是特殊整数。所以总共有 19 个特殊整数。\n\n示例2.\n输入：n = 5\n输出：5\n解释：1 到 5 所有整数都是特殊整数。 \n\n示例3.\n输入：n = 135\n输出：110\n解释：从 1 到 135 总共有 110 个整数是特殊整数。\n不特殊的部分数字为：22 ，114 和 131 。\n\n解题思路+ \n代码参考class Solution:\n    def smallestNumber(self, pattern: str) -&gt; str:\n        n &#x3D; len(pattern)\n        res &#x3D; list(digits[1: n + 2])\n        i &#x3D; 0\n        while i &lt; n:\n            if pattern[i] &#x3D;&#x3D; &#39;I&#39;:\n                i +&#x3D; 1\n                continue\n            st &#x3D; i\n            i +&#x3D; 1\n            while i &lt; n and pattern[i] &#x3D;&#x3D; &#39;D&#39;:\n                i +&#x3D; 1\n            res[st: i + 1] &#x3D; res[st: i + 1][::-1]\n        return &#39;&#39;.join(res)\n","slug":"LeetCode第x题：x","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣","author_index":"秋水"},{"id":"1598e1fbda62dcb3747af5504eee9b77","title":"LeetCode第14题：最长公共前缀","content":"14.最长公共前缀题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n字符串\nNo\n\n\n题目要求编写一个函数来查找字符串数组中的最长公共前缀。\n如果不存在公共前缀，返回空字符串 &quot;&quot;。\n示例示例1.\n输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]\n输出：&quot;fl&quot;\n\n示例2.\n输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]\n输出：&quot;&quot;\n解释：输入不存在公共前缀。\n\n解题思路\n将数组进行按着长度排序，然后利用最短的字符串的内容来匹配后面的字符串\n只要中途断掉一次就直接返回无需重复判断\n\n代码参考class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -&gt; str:\n        strs.sort(key&#x3D;lambda i:len(i))\n        res &#x3D; &#39;&#39;\n        for i in range(len(strs[0])):\n            for j in range(1, len(strs)):\n                if strs[j][i] !&#x3D; strs[0][i]:\n                    return res\n            res +&#x3D; strs[0][i]\n        return res\n\n","slug":"LeetCode第14题：最长公共前缀","date":"2022-10-16T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,字符串","author_index":"秋水"},{"id":"61bb6f5cc8c2b354654a3924ef551bd8","title":"LeetCode第9题：回文数","content":"9.回文数题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n字符串\nNo\n\n\n题目要求给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n例如，121 是回文，而 123 不是。\n\n示例示例1.\n输入：x = 121\n输出：true\n\n示例2.\n输入：x = -121\n输出：false\n解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n\n示例3.\n输入：x = 10\n输出：false\n解释：从右向左读, 为 01 。因此它不是一个回文数。\n\n解题思路\n正着读等于反着读\n\n代码参考class Solution:\n    def isPalindrome(self, x: int) -&gt; bool:\n        return (&#39;&#39;.join(list(str(x)))) &#x3D;&#x3D; (&#39;&#39;.join(list(str(x))[::-1]))\n\n","slug":"LeetCode第9题：回文数","date":"2022-10-16T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,字符串","author_index":"秋水"},{"id":"564a937d2cd48b1701248e7c56119651","title":"LeetCode第904题：水果成篮","content":"904.水果成篮题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n哈希表, 滑动串口\nYes\n\n\n题目要求你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。\n你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：\n\n你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。\n你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上恰好摘一个水果。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。\n一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。\n\n给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。\n示例示例1.\n输入：fruits = [1,2,1]\n输出：3\n解释：可以采摘全部 3 棵树。\n\n示例2.\n输入：fruits = [0,1,2,2]\n输出：3\n解释：可以采摘 [1,2,2] 这三棵树。\n如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。\n\n示例3.\n输入：fruits = [1,2,3,2,2]\n输出：4\n解释：可以采摘 [2,3,2,2] 这四棵树。\n如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。\n\n示例4.\n输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]\n输出：5\n解释：可以采摘 [1,2,1,1,2] 这五棵树。\n\n解题思路\n这种要求连续的，一般是维护一个动态的滑动窗口，定义两个指针来作为窗口长度\n然后因为只有两个篮子，只能采摘两种果实，可以定义一个哈希表来表示窗口中的水果的种类以及计数，顺便当种类大于2时判断窗口左侧要移动多少个单位\n最后定义一个结果变量来动态记录值，窗口的右侧减去左侧加上1就是当前水果篮中的最大值\n\n代码参考class Solution:\n    def totalFruit(self, fruits: List[int]) -&gt; int:\n        count, res, j &#x3D; Counter(), 0, 0\n        for i in range(len(fruits)):\n            count[fruits[i]] +&#x3D; 1\n            while len(count) &gt; 2:\n                tmp &#x3D; fruits[j]\n                count[tmp] -&#x3D; 1\n                if count[tmp] &#x3D;&#x3D; 0:\n                    count.pop(tmp)\n                j +&#x3D; 1\n            res &#x3D; max(res, i - j + 1)\n        return res # i是窗口右侧， j是窗口左侧\n\n","slug":"LeetCode第904题：水果成篮","date":"2022-10-16T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,滑动串口,哈希表","author_index":"秋水"},{"id":"fe174234794c3746e58194d2817c117d","title":"LeetCode第785题：判断二分图","content":"785.判断二分图题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n并查集\nYes\n\n\n题目要求存在一个无向图，图中有n个节点。其中每个节点都有一个介于0到n - 1之间的唯一编号。给你一个二维数组graph，其中graph[u]是一个节点数组，由节点u的邻接节点组成。形式上，对于graph[u]中的每个v，都存在一条位于节点u和节点v 之间的无向边。该无向图同时具有以下属性：\n示例示例1.\n输入：graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\n输出：false\n解释：不能将节点分割成两个独立的子集，以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。\n\n示例2.\n输入：graph = [[1,3],[0,2],[1,3],[0,2]]\n输出：true\n解释：可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;\n\n解题思路\n建立并查集找冲突，与第886题差不多，找到要被连接的节点包含自身时发生冲突\n\n代码参考class Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -&gt; bool:\n\t\tclass UnionFind:\n            def __init__(self, n: int):\n                self.fa &#x3D; list(range(n))\n                self.size &#x3D; [1] * n\n\n            def find(self, x: int) -&gt; int:\n                if self.fa[x] !&#x3D; x:\n                    self.fa[x] &#x3D; self.find(self.fa[x])\n                return self.fa[x]\n\n            def union(self, x: int, y: int) -&gt; None:\n                fx, fy &#x3D; self.find(x), self.find(y)\n                if fx &#x3D;&#x3D; fy:\n                    return\n                if self.size[fx] &lt; self.size[fy]:\n                    fx, fy &#x3D; fy, fx\n                self.size[fx] +&#x3D; self.size[fy]\n                self.fa[fy] &#x3D; fx\n\n            def is_connected(self, x: int, y: int) -&gt; bool:\n                return self.find(x) &#x3D;&#x3D; self.find(y)\n\n        n &#x3D; len(graph)\n        uf &#x3D; UnionFind(n)\n        for x, nodes in enumerate(graph):\n            for y in nodes:\n                uf.union(nodes[0], y)\n                if uf.is_connected(x, y):\n                    return False\n        return True\n\n","slug":"LeetCode第785题：判断二分图","date":"2022-10-15T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,并查集","author_index":"秋水"},{"id":"d8a096fe7b0db144c234f1fea1d80896","title":"LeetCode第856题：括号的分数","content":"856.括号的分数题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n栈, 字符串\nYes\n\n\n题目要求给定一组n给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：\n\n() 得 1 分。\nAB 得 A + B 分，其中 A 和 B 是平衡括号字符串。\n(A) 得 2 * A 分，其中 A 是平衡括号字符串。\n\n示例示例1.\n输入： &quot;()&quot;\n输出： 1\n\n示例2.\n输入： &quot;(())&quot;\n输出： 2\n\n示例3.\n输入： &quot;()()&quot;\n输出： 2\n \n\n示例4.\n输入： &quot;(()(()))&quot;\n输出： 6\n\n解题思路\n由于这种类似与用字符串实现加减乘除的模板，那就很容易想到使用栈来解决\n其次看给出的限定条件，可以知道条件1，条件2是最简单的条件，条件1就直接赋值为1，条件2就直接使用+&#x3D;来计算同时也要考虑一下边界就好了\n条件三如果一个一个情况考虑那就太复杂了，可以使用位运算，定义一个深度的变量，深度多深就左移多少位，刚刚好实现了乘2\n\n代码参考class Solution:\n    def scoreOfParentheses(self, s: str) -&gt; int:\n        res, deep &#x3D; 0, 0\n        for i, v in enumerate(s):\n            deep +&#x3D; 1 if v &#x3D;&#x3D; &#39;(&#39; else -1\n            if v &#x3D;&#x3D; &#39;)&#39; and s[i-1] &#x3D;&#x3D; &#39;(&#39;:\n                res +&#x3D; 1 &lt;&lt; deep\n        return res\n\n","slug":"LeetCode第856题：括号的分数","date":"2022-10-15T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,字符串,栈","author_index":"秋水"},{"id":"59bc9b003b7228540fe2343582c95687","title":"LeetCode第886题：可能的二分法","content":"886.可能的二分法题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n并查集\nYes\n\n\n题目要求给定一组n人(编号为1, 2, ..., n), 我们想把每个人分进任意大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。\n给定整数n和数组dislikes，其中dislikes[i] = [ai, bi]，表示不允许将编号为ai和bi的人归入同一组。当可以用这种方法将所有人分进两组时，返回true；否则返回false。\n示例示例1.\n输入：n = 4, dislikes = [[1,2],[1,3],[2,4]]\n输出：true\n解释：group1 [1,4], group2 [2,3]\n\n示例2.\n输入：n = 3, dislikes = [[1,2],[1,3],[2,3]]\n输出：false\n\n示例3.\n输入：n = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]\n输出：false\n\n解题思路\n先建立一个邻接矩阵来代表每个人不喜欢的人\n然后建立一个并查集，因为只有两组，所以某个人不喜欢的人一定会在一个集合内\n最后我们使用建立的并查集进行连接，如果某个人不喜欢的人和他自身连接了就证明这组关系是有冲突的，不存在这样的二分组\n使用并查集的模板\n\n代码参考class Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -&gt; bool:\n\t\t# UnionFind类为并查集的模板\n        class UnionFind:\n            def __init__(self, n: int):\n                self.fa &#x3D; list(range(n))\n                self.size &#x3D; [1] * n\n\t\t\t\n\t\t\t# 路径压缩\n            def find(self, x: int) -&gt; int:\n                if self.fa[x] !&#x3D; x:\n                    self.fa[x] &#x3D; self.find(self.fa[x])\n                return self.fa[x]\n\n            def union(self, x: int, y: int) -&gt; None:\n                fx, fy &#x3D; self.find(x), self.find(y)\n                if fx &#x3D;&#x3D; fy:\n                    return\n                if self.size[fx] &lt; self.size[fy]:\n                    fx, fy &#x3D; fy, fx\n                self.size[fx] +&#x3D; self.size[fy]\n                self.fa[fy] &#x3D; fx\n\n            def is_connected(self, x: int, y: int) -&gt; bool:\n                return self.find(x) &#x3D;&#x3D; self.find(y)\n\n        diss &#x3D; [[] for _ in range(n)]\n        for x, y in dislikes:\n            diss[x - 1].append(y - 1)\n            diss[y - 1].append(x - 1)\n        uf &#x3D; UnionFind(n)\n        for x, nodes in enumerate(diss):\n            for y in nodes:\n                uf.union(nodes[0], y) # 处理每个人不喜欢的人的父节点\n                if uf.is_connected(x, y): # 处理过程中发现冲突直接返回\n                    return False\n        return True\n\n","slug":"LeetCode第886题：可能的二分法","date":"2022-10-15T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,并查集","author_index":"秋水"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"NOTHING!!(后续跟新print(&quot;hello world&quot;)\n","slug":"hello-world","date":"2022-10-15T02:41:39.690Z","categories_index":"","tags_index":"","author_index":"秋水"},{"id":"c0524bc960f43aa892c6edbb08789fd2","title":"LeetCode第107题：二叉树的层序遍历 II","content":"107.二叉树的层序遍历 II题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n树,BFS\nYes\n\n\n题目要求给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）。\n示例示例1.\n输入：root = [3,9,20,null,null,15,7]\n输出：[[15,7],[9,20],[3]]\n\n解题思路\n利用树的BFS模板，得到结果列表反转即可\n\n代码参考class Solution:\n    def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]:\n        if not root:\n            return []\n        temp_res &#x3D; [root]\n        res &#x3D; []\n        while temp_res:\n            res.append([i.val for i in temp_res])\n            next_level &#x3D; []\n            for i in temp_res:\n                if i.left:\n                    next_level.append(i.left)\n                if i.right:\n                    next_level.append(i.right)\n            temp_res &#x3D; next_level\n\t\t# 以上为树的广度搜索的模板\n        res.reverse()\n        return res\n\n","slug":"LeetCode第107题：二叉树的层序遍历 II","date":"2022-10-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,树,BFS","author_index":"秋水"},{"id":"2e71333626c3011cee190883801aa78f","title":"LeetCode第237题：删除链表中的节点","content":"237.删除链表中的节点题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n链表\nNo\n\n\n题目要求请编写一个函数，用于 删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问 要被删除的节点 。\n题目数据保证需要删除的节点 不是末尾节点 。\n示例示例1.\n输入：head = [4,5,1,9], node = 5\n输出：[4,1,9]\n解释：指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9\n\n示例2.\n输入：head = [4,5,1,9], node = 1\n输出：[4,5,9]\n解释：指定链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9\n\n解题思路\n由于我们不无法获取链表的头，所以编写函数需返回任何值\n我们无法获取头，也就是说我们无法对要删除的链表的前驱进行操作\n我们只需要将要删除的节点的后继的值覆盖删除节点的值\n然后将链表的倒数二个节点的后继置空，就完成了删除节点的操作\n\n代码参考#\n# @lc app&#x3D;leetcode.cn id&#x3D;237 lang&#x3D;python3\n#\n# [237] 删除链表中的节点\n#\n\n# @lc code&#x3D;start\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val &#x3D; x\n#         self.next &#x3D; None\n\nclass Solution:\n\tdef deleteNode(self, node):\n\t\t&quot;&quot;&quot;\n\t\t:type node: ListNode\n\t\t:rtype: void Do not return anything, modify node in-place instead.\n\t\t&quot;&quot;&quot;\n\t\tnode1 &#x3D; node\n\t\twhile node.next:\n\t\t\tnode.val &#x3D; node.next.val\n\t\t\tif node.next.next:\n\t\t\t\tnode &#x3D; node.next\n\t\t\telse:\n\t\t\t\tnode.next &#x3D; None\n# @lc code&#x3D;end\n\n","slug":"LeetCode第237题：删除链表中的节点","date":"2022-10-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,链表","author_index":"秋水"},{"id":"3f9b149edda744a0462c85c999c4b231","title":"LeetCode第1441题：用栈操作构建数组","content":"1441.用栈操作构建数组题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n栈,模拟\nNo\n\n\n题目要求给你一个数组 target 和一个整数 n。每次迭代，需要从  list = [1, 2, 3,..., n]中依次读取一个数字。请使用下述操作来构建目标数组 target ：\n\n&quot;Push&quot;：从 list 中读取一个新元素， 并将其推入数组中。\n&quot;Pop&quot;：删除数组中的最后一个元素。\n如果目标数组构建完成，就停止读取更多元素。\n\n题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。请返回构建目标数组所用的操作序列。如果存在多个可行方案，返回任一即可。\n示例示例1.\n输入：target = [1,3], n = 3\n输出：[&quot;Push&quot;,&quot;Push&quot;,&quot;Pop&quot;,&quot;Push&quot;]\n解释： \n读取 1 并自动推入数组 -&gt; [1]\n读取 2 并自动推入数组，然后删除它 -&gt; [1]\n读取 3 并自动推入数组 -&gt; [1,3]\n\n示例2.\n输入：target = [1,2,3], n = 3\n输出：[&quot;Push&quot;,&quot;Push&quot;,&quot;Push&quot;]\n\n示例3.\n**输入：**target = [1,2], n = 4\n**输出：**[&quot;Push&quot;,&quot;Push&quot;]\n**解释：**只需要读取前 2 个数字就可以停止。\n\n解题思路\n将target以字典形式存储，减少查找时间\n如果1-n中含target只需入栈“Push”即可，若不存在则先入“Push”再入“Pop”\n最后若max(target) &lt; n的话只用判断到target最大的值即可终止循环\n\n代码参考class Solution:\n\tdef buildArray(self, target: List[int], n: int) -&gt; List[str]:\n\t\ttar &#x3D; set(target)\n\t\tres &#x3D; []\n\t\tfor i in range(1, max(tar) + 1):\n\t\t\tres.append(&#39;Push&#39;)\n\t\t\tif i in tar:\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tres.append(&#39;Pop&#39;)\n\t\treturn res\n\n","slug":"LeetCode第1441题：用栈操作构建数组","date":"2022-10-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,栈,模拟","author_index":"秋水"},{"id":"91986e7de18a1f0d056c15eb6d3ad084","title":"LeetCode第575题：分糖果","content":"575.分糖果题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEesy\n脑筋急转弯\nNo\n\n\n题目要求 Alice 有 n 枚糖，其中第 i 枚糖的类型为 candyType[i] 。Alice 注意到她的体重正在增长，所以前去拜访了一位医生。\n医生建议 Alice 要少摄入糖分，只吃掉她所有糖的 n / 2 即可（n 是一个偶数）。Alice 非常喜欢这些糖，她想要在遵循医生建议的情况下，尽可能吃到最多不同种类的糖。\n给你一个长度为 n 的整数数组 candyType ，返回： Alice 在仅吃掉 n / 2 枚糖的情况下，可以吃到糖的最多种类数。\n示例示例1.\n输入：candyType = [1,1,2,2,3,3]\n输出：3\n解释：Alice 只能吃 6 / 2 = 3 枚糖，由于只有 3 种糖，她可以每种吃一枚。\n\n示例2.\n输入：candyType = [1,1,2,3]\n输出：2\n解释：Alice 只能吃 4 / 2 = 2 枚糖，不管她选择吃的种类是 [1,2]、[1,3] 还是 [2,3]，她只能吃到两种不同类的糖。\n\n示例3.\n输入：candyType = [6,6,6,6]\n输出：1\n解释：Alice 只能吃 4 / 2 = 2 枚糖，尽管她能吃 2 枚，但只能吃到 1 种糖。\n\n解题思路\n只需考虑两张极端思路即可得出答案\nAlice最多能吃len(candyType)的一半或者元素都相同则怎么吃都是一种\n最后只需判断是是candyType的长度一半大还是candyType的字典长度大即可\n\n代码参考class Solution:\n    def distributeCandies(self, candyType: List[int]) -&gt; int:\n        return len(candyType) &#x2F;&#x2F; 2 if len(set(candyType)) &gt; len(candyType) &#x2F;&#x2F; 2 else len(set(candyType))\n\n","slug":"LeetCode第575题：分糖果","date":"2022-10-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,脑筋急转弯","author_index":"秋水"},{"id":"21e1d52c3b2ce6bf6d44dddedefce323","title":"LeetCode第61题：旋转链表","content":"61.旋转链表题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n链表\nYes\n\n\n题目要求给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\n示例示例1.\n输入：head = [1,2,3,4,5], k = 2\n输出：[4,5,1,2,3]\n\n示例2.\n输入：head = [0,1,2], k = 4\n输出：[2,0,1]\n\n解题思路\n这种旋转的思路都大致相同，将两个相同的链表连接，然后再减去多余步数，即使答案\n例如示例二可变为：0-&gt;1-&gt;2-&gt;0-&gt;1-&gt;2，然后4是大于自身3的长度即用k去取余长度即使真正的步数，真正的步数永远不会大于两倍的lenght，所以只要在遍历一遍然后用长度减去真正的步数即使答案所求链表\n\n代码参考# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val&#x3D;0, next&#x3D;None):\n#         self.val &#x3D; val\n#         self.next &#x3D; next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:\n        if not head or not head.next or k &#x3D;&#x3D; 0:\n            return head\n        node &#x3D; ListNode(0)\n        node.next &#x3D; head\n        p1 &#x3D; node\n        lenght &#x3D; 0\n        while p1.next:\n            lenght +&#x3D; 1\n            p1 &#x3D; p1.next\n        if k % lenght &#x3D;&#x3D; 0:\n            return head\n        p1.next &#x3D; head\n        p1 &#x3D; node\n        i &#x3D; lenght - (k % lenght)\n        while i:\n            p1 &#x3D; p1.next\n            i -&#x3D; 1\n        result &#x3D; ListNode(0)\n        result.next &#x3D; p1.next\n        p1.next &#x3D; None\n        return result.next\n\n","slug":"LeetCode第61题：旋转链表","date":"2022-10-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,链表","author_index":"秋水"},{"id":"cecf4faf8156d8be7b73bb8270261e34","title":"LeetCode第64题：最小路径和","content":"64.最小路径和题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n动态规划\nYes\n\n\n题目要求给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n说明：每次只能向下或者向右移动一步。\n示例示例1.\n输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\n输出：7\n解释：因为路径 1→3→1→1→1 的总和最小。\n\n解题思路\n这种步步要精打细算很容易想到要求贪心算法或者动态规划\n但是贪心算法可能陷入局部最优所以采用动态规划\n先计算边缘格子的移动Cost，然后再利用双重循环的最小Cost来判断是往右还是往下走\n\n代码参考class Solution:\n    def minPathSum(self, grid: List[List[int]]) -&gt; int:\n        m, n &#x3D; len(grid), len(grid[0])\n        dp &#x3D; [[0] * n for _ in range(m)]\n        dp[0][0] &#x3D; grid[0][0]\n        for i in range(1, m):\n            dp[i][0] &#x3D; dp[i-1][0] + grid[i][0]\n        for j in range(1, n):\n            dp[0][j] &#x3D; dp[0][j-1] + grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] &#x3D; min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        return dp[m-1][n-1]\n\n","slug":"LeetCode第64题：最小路径和","date":"2022-10-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,动态规划,Like","author_index":"秋水"}]