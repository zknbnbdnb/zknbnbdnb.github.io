[{"id":"c7b79577f2ea1c8b47e6d7a622a64529","title":"LeetCode第746题：使用最小花费爬楼梯","content":"746.使用最小花费爬楼梯题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n动态规划\nYes\n\n\n题目要求给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。\n你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。\n请你计算并返回达到楼梯顶部的最低花费。\n示例示例1.\n输入：cost = [10,15,20]\n输出：15\n解释：你将从下标为 1 的台阶开始。\n- 支付 15 ，向上爬两个台阶，到达楼梯顶部。\n总花费为 15 。\n\n示例2.\n输入：cost = [1,100,1,1,1,100,1,1,100,1]\n输出：6\n解释：你将从下标为 0 的台阶开始。\n- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。\n- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。\n- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。\n- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。\n- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。\n- 支付 1 ，向上爬一个台阶，到达楼梯顶部。\n总花费为 6 。\n\n解题思路\n建立一个动态规划数组，然后分别对当前步的最优解进行计算，最后比较数组最后两位大小计划\n\n代码参考class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -&gt; int:\n        n &#x3D; len(cost)\n        dp &#x3D; [0] * n\n        dp[0] &#x3D; cost[0]\n        dp[1] &#x3D; cost[1]\n        for i in range(2, n):\n\t        # 能走一步或者两步\n            dp[i] &#x3D; min(dp[i - 1], dp[i - 2]) + cost[i]\n        return min(dp[-1], dp[-2])               \n\n","slug":"LeetCode第746题：使用最小花费爬楼梯","date":"2022-10-27T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,动态规划,Like","author_index":"秋水"},{"id":"5d2a82a6eb0a78f238e97d50a64217cd","title":"LeetCode第862题：和至少为K的最短子数组","content":"862.和至少为K的最短子数组题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nHard\n前缀和， 单调序列\nYes\n\n\n题目要求给你一个整数数组nums和一个整数k，找出nums中和至少为k的最短非空子数组，并返回该子数组的长度。如果不存在这样的子数组 ，返回 -1 。\n子数组 是数组中 连续 的一部分。\n示例示例1.\n输入：nums = [1], k = 1\n输出：1\n\n示例2.\n输入：nums = [1,2], k = 4\n输出：-1\n\n示例3.\n输入：nums = [2,-1,2], k = 3\n输出：3\n\n解题思路\n施工\n\n代码参考class Solution:\n    def shortestSubarray(self, nums: List[int], k: int) -&gt; int:\n        n &#x3D; len(nums)\n        prefix &#x3D; [0] * (n + 1)\n        # for i in range(n):\n        #     prefix[i + 1] &#x3D; prefix[i] + nums[i]\n        prefix &#x3D; list(accumulate(nums, initial&#x3D;0))\n        # 单调递增队列\n        queue &#x3D; deque()\n        ans &#x3D; n + 1\n        for i in range(n + 1):\n            while queue and prefix[i] &lt;&#x3D; prefix[queue[-1]]:\n                queue.pop()\n            while queue and prefix[i] - prefix[queue[0]] &gt;&#x3D; k:\n                ans &#x3D; min(ans, i - queue.popleft())\n            queue.append(i)\n        return ans if ans &lt;&#x3D; n else -1                \n\n","slug":"LeetCode第862题：和至少为K的最短子数组","date":"2022-10-25T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,前缀和,单调队列","author_index":"秋水"},{"id":"ff9cba5b8b7de2a383f36699c064fa18","title":"LeetCode第934题：最短的桥","content":"934.分割数组题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n图，BFS\nYes\n\n\n题目要求给你一个大小为 n x n 的二元矩阵 grid ，其中 1 表示陆地，0 表示水域。\n岛 是由四面相连的 1 形成的一个最大组，即不会与非组内的任何其他 1 相连。grid 中 恰好存在两座岛 。\n你可以将任意数量的 0 变为 1 ，以使两座岛连接起来，变成 一座岛 。\n返回必须翻转的 0 的最小数目。\n示例示例1.\n输入：grid = [[0,1],[1,0]]\n输出：1\n\n示例2.\n输入：grid = [[0,1,0],[0,0,0],[0,0,1]]\n输出：2\n\n示例3.\n输入：grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\n输出：1\n\n解题思路\n施工中\n\n代码参考class Solution:\n    def shortestBridge(self, grid: List[List[int]]) -&gt; int:\n        n &#x3D; len(grid)\n        visit &#x3D; [[False] * n for _ in range(n)]\n\n        def bfs(i, j):\n            q &#x3D; deque()\n            q.appendleft((i, j, 0))\n            while q:\n                m &#x3D; len(q)\n                for _ in range(m):\n                    i, j, d &#x3D; q.popleft()\n                    for x, y in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                        tmpX, tmpY &#x3D; i + x, j + y\n                        if 0 &lt;&#x3D; tmpX &lt; n and 0 &lt;&#x3D; tmpY &lt; n and not visit[tmpX][tmpY]:\n                            visit[tmpX][tmpY] &#x3D; True\n                            if grid[tmpX][tmpY] &#x3D;&#x3D; 1:\n                                if d &gt; 0:\n                                    return d\n                                else:\n                                    q.appendleft((tmpX, tmpY, 0))\n                            else:\n                                q.append((tmpX, tmpY, d + 1))\n\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] &#x3D;&#x3D; 1:\n                    visit[i][j] &#x3D; True\n                    return bfs(i, j)                \n\n","slug":"LeetCode第934题：最短的桥","date":"2022-10-24T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,BFS,图","author_index":"秋水"},{"id":"4a3177ea8454ccb231fecc2d43270156","title":"LeetCode第1620题：网络信号最好的坐标","content":"1620.网络信号最好的坐标题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n枚举\nNo\n\n\n题目要求给你一个数组 towers 和一个整数 radius 。\n数组  towers  中包含一些网络信号塔，其中 towers[i] = [xi, yi, qi]表示第 i 个网络信号塔的坐标是 (xi, yi) 且信号强度参数为 qi 。所有坐标都是在  X-Y 坐标系内的 整数 坐标。两个坐标之间的距离用 欧几里得距离 计算。\n整数 radius 表示一个塔 能到达 的 最远距离 。如果一个坐标跟塔的距离在 radius 以内，那么该塔的信号可以到达该坐标。在这个范围以外信号会很微弱，所以 radius 以外的距离该塔是 不能到达的 。\n如果第 i 个塔能到达 (x, y) ，那么该塔在此处的信号为 ⌊qi / (1 + d)⌋ ，其中 d 是塔跟此坐标的距离。一个坐标的 信号强度 是所有 能到达 该坐标的塔的信号强度之和。\n请你返回数组 [cx, cy] ，表示 信号强度 最大的 整数 坐标点 (cx, cy)如果有多个坐标网络信号一样大，请你返回字典序最小的 非负 坐标。\n注意：\n\n坐标 (x1, y1) 字典序比另一个坐标 (x2, y2) 小，需满足以下条件之一：\n\n要么 x1 &lt; x2 ，\n要么 x1 == x2 且 y1 &lt; y2\n\n\n\n\n⌊val⌋ 表示小于等于 val 的最大整数（向下取整函数）。\n\n示例示例1.\n输入：towers = [[1,2,5],[2,1,7],[3,1,9]], radius = 2\n输出：[2,1]\n解释：\n坐标 (2, 1) 信号强度之和为 13\n- 塔 (2, 1) 强度参数为 7 ，在该点强度为 ⌊7 / (1 + sqrt(0)⌋ = ⌊7⌋ = 7\n- 塔 (1, 2) 强度参数为 5 ，在该点强度为 ⌊5 / (1 + sqrt(2)⌋ = ⌊2.07⌋ = 2\n- 塔 (3, 1) 强度参数为 9 ，在该点强度为 ⌊9 / (1 + sqrt(1)⌋ = ⌊4.5⌋ = 4\n没有别的坐标有更大的信号强度。\n\n示例2.\n输入：towers = [[1,2,13],[2,1,7],[0,1,9]], radius = 2\n输出：[1,2]\n解释：坐标 (1, 2) 的信号强度最大。\n\n解题思路\n首先先将塔中x的最大值和最小值还有y的最大值和最小值提取出来，来进行网格搜索\n然后遍历每个塔求欧式距离看是否再radius之内\n动态变化最大信号，由于是顺序网格搜索，那么得到的坐标一定满足最小字典序\n\n代码参考class Solution:\n    def bestCoordinate(self, towers: List[List[int]], radius: int) -&gt; List[int]:\n        L &#x3D; len(towers)\n        res_x, res_y, res_q &#x3D; 0, 0, 0\n        m &#x3D; max(t[0] for t in towers)\n        n &#x3D; max(t[1] for t in towers)\n        min_n &#x3D; min(t[0] for t in towers)\n        min_m &#x3D; min(t[1] for t in towers)\n        for i in range(min_m, m + 1):\n            for j in range(min_n, n + 1):\n                tmp &#x3D; 0\n                for k in range(L):\n                    x, y, q &#x3D; towers[k]\n                    if (x - i) ** 2 + (y - j) ** 2 &lt;&#x3D; radius ** 2:\n                        tmp +&#x3D; q &#x2F;&#x2F; (1 + ((x - i) ** 2 + (y - j) ** 2) ** 0.5)\n                if tmp &gt; res_q:\n                    res_q &#x3D; tmp\n                    res_x, res_y &#x3D; i, j\n        return [res_x, res_y]          \n\n","slug":"LeetCode第1620题：网络信号最好的坐标","date":"2022-11-01T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,枚举","author_index":"秋水"},{"id":"7e4e6dc810b8551c74f0419324323453","title":"LeetCode第1662题：检查两个字符串组是否相等","content":"784.检查两个字符串组是否相等题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n模拟\nNo\n\n\n题目要求给你两个字符串数组 word1 和 word2 。如果两个数组表示的字符串相同，返回 true ；否则，返回 false 。\n数组表示的字符串 是由数组中的所有元素 按顺序 连接形成的字符串。\n示例示例1.\n输入：word1 = [&quot;ab&quot;, &quot;c&quot;], word2 = [&quot;a&quot;, &quot;bc&quot;]\n输出：true\n解释：\nword1 表示的字符串为 &quot;ab&quot; + &quot;c&quot; -&gt; &quot;abc&quot;\nword2 表示的字符串为 &quot;a&quot; + &quot;bc&quot; -&gt; &quot;abc&quot;\n两个字符串相同，返回 true\n\n示例2.\n输入：word1 = [&quot;a&quot;, &quot;cb&quot;], word2 = [&quot;ab&quot;, &quot;c&quot;]\n输出：false\n\n解题思路\n太简单了\n\n代码参考class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -&gt; bool:\n        return &#39;&#39;.join(word1) &#x3D;&#x3D; &#39;&#39;.join(word2)           \n\n","slug":"LeetCode第1662题：检查两个字符串组是否相等","date":"2022-10-31T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,模拟","author_index":"秋水"},{"id":"0b3eb51ddb9a9608cd3f44c6e963cf10","title":"LeetCode第784题：字母大小全排列","content":"784.字母大小全排列题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n枚举\nYes\n\n\n题目要求给定一个字符串 s ，通过将字符串 s 中的每个字母转变大小写，我们可以获得一个新的字符串。\n返回 所有可能得到的字符串集合 。以 任意顺序 返回输出。\n示例示例1.\n输入：s = &quot;a1b2&quot;\n输出：[&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]\n\n示例2.\n输入: s = &quot;3z4&quot;\n输出: [&quot;3z4&quot;,&quot;3Z4&quot;]\n\n解题思路\n如果遇到字母就分大小写加入一次结果即可，使用ord查看Acill码来确定字母\n\n代码参考class Solution:\n    def letterCasePermutation(self, s: str) -&gt; List[str]:\n        res &#x3D; [&#39;&#39;]\n        for c in s:\n            if 65 &lt;&#x3D; ord(c) &lt;&#x3D; 90 or 97 &lt;&#x3D; ord(c) &lt;&#x3D; 122:\n                res &#x3D; [r + c.lower() for r in res] + [r + c.upper() for r in res]\n            else:\n                res &#x3D; [r + c for r in res]\n        return res             \n\n","slug":"LeetCode第784题：字母大小全排列","date":"2022-10-29T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,枚举","author_index":"秋水"},{"id":"9f8d6e353a3cc9a4289af79ee7380137","title":"LeetCode第628题：三个数最大乘积","content":"628.三个数最大乘积题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n排序\nNo\n\n\n题目要求给你一个整型数组 nums ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。\n示例示例1.\n输入：nums = [1,2,3]\n输出：6\n\n示例2.\n输入：nums = [1,2,3,4]\n输出：24\n\n示例3.\n输入：nums = [-1,-2,-3]\n输出：-6\n\n解题思路\n首先将数组进行排序，由提示可知由可能会出现负数，那么只需要将前两个相乘再与最后一个相乘和最后三个相乘进行比较即可\n\n代码参考class Solution:\n    def maximumProduct(self, nums: List[int]) -&gt; int:\n        nums.sort()\n        return max(nums[-1] * nums[-2] * nums[-3], nums[-1] * nums[0] * nums[1])                     \n\n","slug":"LeetCode第628题：三个数最大乘积","date":"2022-10-25T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,排序","author_index":"秋水"},{"id":"f7dba2635a51e15fd0fffbe2f3d3b59e","title":"LeetCode第661题：图片平滑器","content":"661.图片平滑器题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n模拟\nNo\n\n\n题目要求图像平滑器 是大小为 3 x 3 的过滤器，用于对图像的每个单元格平滑处理，平滑处理后单元格的值为该单元格的平均灰度。\n每个单元格的  平均灰度 定义为：该单元格自身及其周围的 8 个单元格的平均值，结果需向下取整。（即，需要计算蓝色平滑器中 9 个单元格的平均值）。\n如果一个单元格周围存在单元格缺失的情况，则计算平均灰度时不考虑缺失的单元格（即，需要计算红色平滑器中 4 个单元格的平均值）。\n\n给你一个表示图像灰度的 m x n 整数矩阵 img ，返回对图像的每个单元格平滑处理后的图像 。\n示例示例1.\n输入:img = [[1,1,1],[1,0,1],[1,1,1]]\n输出:[[0, 0, 0],[0, 0, 0], [0, 0, 0]]\n解释:\n对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0\n对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0\n对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0\n\n示例2.\n输入: img = [[100,200,100],[200,50,200],[100,200,100]]\n输出: [[137,141,137],[141,138,141],[137,141,137]]\n解释:\n对于点 (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137\n对于点 (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141\n对于点 (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138\n\n解题思路\n模拟过程即可，记得注意判断边界条件\n\n代码参考class Solution:\n    def imageSmoother(self, img: List[List[int]]) -&gt; List[List[int]]:\n        m, n &#x3D; len(img), len(img[0])\n        ans &#x3D; [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                count &#x3D; 0\n                for di in range(-1, 2):\n                    for dj in range(-1, 2):\n                        if 0 &lt;&#x3D; i + di &lt; m and 0 &lt;&#x3D; j + dj &lt; n:\n                            ans[i][j] +&#x3D; img[i + di][j + dj]\n                            count +&#x3D; 1\n                ans[i][j] &#x2F;&#x2F;&#x3D; count\n        return ans           \n\n","slug":"LeetCode第661题：图片平滑器","date":"2022-10-25T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,模拟","author_index":"秋水"},{"id":"ac6fbac8b58301151c5e3f9393ea868c","title":"LeetCode第868题：二进制间距","content":"868.二进制间距题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n模拟\nNo\n\n\n题目要求给定一个正整数 n，找到并返回 n 的二进制表示中两个 相邻 1 之间的 最长距离 。如果不存在两个相邻的 1，返回 0 。\n如果只有 0 将两个 1 分隔开（可能不存在 0 ），则认为这两个 1 彼此 相邻 。两个 1 之间的距离是它们的二进制表示中位置的绝对差。例如，&quot;1001&quot; 中的两个 1 的距离为 3 。\n示例示例1.\n输入：n = 22\n输出：2\n解释：22 的二进制是 &quot;10110&quot; 。\n在 22 的二进制表示中，有三个 1，组成两对相邻的 1 。\n第一对相邻的 1 中，两个 1 之间的距离为 2 。\n第二对相邻的 1 中，两个 1 之间的距离为 1 。\n答案取两个距离之中最大的，也就是 2 。\n\n示例2.\n输入：n = 8\n输出：0\n解释：8 的二进制是 &quot;1000&quot; 。\n在 8 的二进制表示中没有相邻的两个 1，所以返回 0 。\n\n示例3.\n输入：n = 5\n输出：2\n解释：5 的二进制是 &quot;101&quot; 。\n\n解题思路\n先利用bin()函数转为二进制字符串，记得要切片，然后判断里面&#39;1&#39;的个数，若为1则直接返回0\n然后声明tmp来用来记录&#39;1&#39;的位置，res来记录答案\n然后动态跟新res即可\n\n代码参考class Solution:\n    def binaryGap(self, n: int) -&gt; int:\n        temp &#x3D; bin(n)[2:]\n        if temp.count(&quot;1&quot;) &lt;&#x3D; 1:\n            return 0\n        else:\n            res &#x3D; 0\n            tmp, res &#x3D; 0, 0\n            for i in range(len(temp)):\n                if int(temp[i]):\n                    res &#x3D; max(res, i - tmp)\n                    tmp &#x3D; i\n            return res                    \n\n","slug":"LeetCode第868题：二进制间距","date":"2022-10-25T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,模拟","author_index":"秋水"},{"id":"1fa7950f9ce8a9e00009e458ff2af6e1","title":"LeetCode第657题：机器人能否返回原点","content":"657.机器人能否返回原点题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n模拟\nNo\n\n\n题目要求在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。\n移动顺序由字符串 moves 表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。\n如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。\n注意： 机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。\n示例示例1.\n输入: moves = &quot;UD&quot;\n输出: true\n解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。\n\n示例2.\n输入: moves = &quot;LL&quot;\n输出: false\n解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。\n\n解题思路\n只需判断向上与向下和向左或者向右的步数是否相同即可\n\n代码参考class Solution:\n    def judgeCircle(self, moves: str) -&gt; bool:\n        return True if moves.count(&#39;L&#39;) &#x3D;&#x3D; moves.count(&#39;R&#39;) and moves.count(&#39;U&#39;) &#x3D;&#x3D; moves.count(&#39;D&#39;) else False1                \n\n","slug":"LeetCode第657题：机器人能否返回原点","date":"2022-10-25T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,模拟","author_index":"秋水"},{"id":"1fa7950f9ce8a9e00009e458ff2af6e1","title":"LeetCode第657题：机器人能否返回原点","content":"657.机器人能否返回原点题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n哈希表，正则表达式\nNo\n\n\n题目要求给你一个字符串 licensePlate 和一个字符串数组 words ，请你找出 words 中的 最短补全词 。\n补全词 是一个包含 licensePlate 中所有字母的单词。忽略 licensePlate 中的 数字和空格 。不区分大小写。如果某个字母在 licensePlate中出现不止一次，那么该字母在补全词中的出现次数应当一致或者更多。\n如：licensePlate = &quot;aBc 12c&quot;，那么它的补全词应当包含字母 &#39;a&#39;、&#39;b&#39; （忽略大写）和两个 &#39;c&#39; 。能的 补全词 有 &quot;abccdef&quot;、&quot;caaacab&quot; 以及 &quot;cbca&quot; 。\n请返回 words 中的 最短补全词 。题目数据保证一定存在一个最短补全词。当有多个单词都符合最短补全词的匹配条件时取 words 中 第一个 出现的那个。\n示例示例1.\n输入：licensePlate = &quot;1s3 PSt&quot;, words = [&quot;step&quot;, &quot;steps&quot;, &quot;stripe&quot;, &quot;stepple&quot;]\n输出：&quot;steps&quot;\n解释：最短补全词应该包括 &quot;s&quot;、&quot;p&quot;、&quot;s&quot;（忽略大小写） 以及 &quot;t&quot;。\n&quot;step&quot; 包含 &quot;t&quot;、&quot;p&quot;，但只包含一个 &quot;s&quot;，所以它不符合条件。\n&quot;steps&quot; 包含 &quot;t&quot;、&quot;p&quot; 和两个 &quot;s&quot;。\n&quot;stripe&quot; 缺一个 &quot;s&quot;。\n&quot;stepple&quot; 缺一个 &quot;s&quot;。\n因此，&quot;steps&quot; 是唯一一个包含所有字母的单词，也是本例的答案。\n\n示例2.\n输入：licensePlate = &quot;1s3 456&quot;, words = [&quot;looks&quot;, &quot;pest&quot;, &quot;stew&quot;, &quot;show&quot;]\n输出：&quot;pest&quot;\n解释：licensePlate 只包含字母 &quot;s&quot; 。所有的单词都包含字母 &quot;s&quot; ，其中 &quot;pest&quot;、&quot;stew&quot;、和 &quot;show&quot; 三者最短。答案是 &quot;pest&quot; ，因为它是三个单词中在 words 里最靠前的那个。\n\n解题思路\n先用正则表达式将licensePlate的字母字符串提取出来并且转化为小写\n再利用Counter()函数来用字典计数，只用当words里的单词的字典计数中每个元素都大于licensePlate 的字典计数，则加入结果表\n对长度进行排序，返回第一个元素即可\n\n代码参考class Solution:\n    def shortestCompletingWord(self, licensePlate: str, words: List[str]) -&gt; str:\n        pattern &#x3D; r&#39;[a-zA-Z]&#39;\n        licensePlate &#x3D; &#39;&#39;.join(re.findall(pattern, licensePlate)).lower()\n        l &#x3D; Counter(licensePlate)\n        res &#x3D; []\n        for word in words:\n            w &#x3D; Counter(word)\n            if all(w[c] &gt;&#x3D; l[c] for c in l):\n                res.append(word)\n        return min(res, key&#x3D;len)             \n\n","slug":"LeetCode第748题：最短补全词","date":"2022-10-25T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,哈希表,正则表达式","author_index":"秋水"},{"id":"60ae9b2236445285bb11efafcfb5a9e1","title":"LeetCode第908题：最小差值 I","content":"908.最小差值 I题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n数学\nNo\n\n\n题目要求给你一个整数数组 nums，和一个整数 k 。\n在一个操作中，您可以选择 0 &lt;= i &lt; nums.length 的任何索引 i。将 nums[i] 改为 nums[i] + x ，其中 x 是一个范围为 [-k, k] 的整数。对于每个索引 i ，最多 只能 应用 一次 此操作。\nnums 的 分数 是 nums 中最大和最小元素的差值。\n在对  nums 中的每个索引最多应用一次上述操作后，返回 nums 的最低 分数。\n示例示例1.\n输入：nums = [1], k = 0\n\n输出：0解释：分数是 max(nums) - min(nums) &#x3D; 1 - 1 &#x3D; 0。。\n示例1.\n输入：nums = [0,10], k = 2\n输出：6\n解释：将 nums 改为 [2,8]。分数是 max(nums) - min(nums) = 8 - 2 = 6。\n\n示例2.\n输入：nums = [1,3,6], k = 3\n输出：0\n解释：将 nums 改为 [4,4,4]。分数是 max(nums) - min(nums) = 4 - 4 = 0。\n\n解题思路\n直接判断最大值最小值的插值是否大于k的两倍\n大于： 返回最大值减去最小值再减去2倍的k\n小于： 返回0\n\n\n因为最小差值不可能为负数\n\n代码参考class Solution:\n    def smallestRangeI(self, nums: List[int], k: int) -&gt; int:\n        if len(nums) &#x3D;&#x3D; 1:\n            return 0\n        return 0 if max(nums) - min(nums) &lt; 2 * k else max(nums) - min(nums) - 2 * k                 \n\n","slug":"LeetCode第908题：最小差值 I","date":"2022-10-25T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,数学","author_index":"秋水"},{"id":"34ac10ca8d0f674926a26899fec9e8e3","title":"LeetCode第728题：自除数","content":"728.自除数题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n模拟\nNo\n\n\n题目要求自除数 是指可以被它包含的每一位数整除的数。\n\n例如，128 是一个 自除数 ，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。\n\n除数 不允许包含 0 。\n整数 left 和 right ，返回一个列表，列表的元素是范围 [left, right] 内所有的 自除数 。\n示例示例1.\n输入：left = 1, right = 22\n输出：[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n\n示例2.\n输入：left = 47, right = 85\n输出：[48,55,66,77]\n\n解题思路\n首先将数字变为字符串然后提取每一位上的数值，若是出现0直接跳过\n然后模拟题目中的过程，若是全满足就加入结果列表\n\n代码参考class Solution:\n    def selfDividingNumbers(self, left: int, right: int) -&gt; List[int]:\n        res &#x3D; []\n        for i in range(left, right + 1):\n            flag &#x3D; 1\n            tmp &#x3D; list(str(i))\n            if &#39;0&#39; in tmp:\n                continue\n            for j in tmp:\n                if i % int(j) !&#x3D; 0:\n                    flag &#x3D; 0\n                    break\n            if flag:\n                res.append(i)\n        return res              \n\n","slug":"LeetCode第728题：自除数","date":"2022-10-25T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,模拟","author_index":"秋水"},{"id":"0f3d1db1a99e73a2fd7bb9005e4afdd5","title":"LeetCode第915题：分割数组","content":"1768.分割数组题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n数组\nNo\n\n\n题目要求给定一个数组 nums ，将其划分为两个连续子数组 left 和 right， 使得：\n\nleft 中的每个元素都小于或等于 right 中的每个元素。\nleft 和 right 都是非空的。\nleft 的长度要尽可能小。\n\n在完成这样的分组后返回 left 的 长度。\n用例可以保证存在这样的划分方法。\n示例示例1.\n输入：nums = [5,0,3,8,6]\n输出：3\n解释：left = [5,0,3]，right = [8,6]\n\n示例2.\n输入：nums = [1,1,1,0,6,12]\n输出：4\n解释：left = [1,1,1,0]，right = [6,12]\n\n解题思路\n先定义两个参数，即max_num和left_num\n然后当当前数组元素小于left_num时，就将left_num这一参数跟新为左边数组最大值，是为了找到分界点，以及其索引idx也记录下来，最后答案返回其索引加一即可\n当等于时不需要考虑，因为要返回最小的left长度\n当大于时则将max_num跟新为当前nums里的值即可\n\n代码参考class Solution:\n    def partitionDisjoint(self, nums: List[int]) -&gt; int:\n        left_max &#x3D; nums[0]\n        max_nums &#x3D; nums[0]\n        idx &#x3D; 0\n        for i in range(1, len(nums)):\n            if nums[i] &lt; left_max:\n                left_max &#x3D; max_nums\n                idx &#x3D; i\n            elif nums[i] &gt; max_nums:\n                max_nums &#x3D; nums[i]\n        return idx + 1                \n\n","slug":"LeetCode第915题：分割数组","date":"2022-10-23T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,数组","author_index":"秋水"},{"id":"579dc2387cd95c31d214d584865cf827","title":"LeetCode第1235题：规划兼职工作","content":"1235.规划兼职工作题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nHard\n动态规划\nYes\n\n\n题目要求你打算利用空闲时间来做兼职工作赚些零花钱。\n这里有 n 份兼职工作，每份工作预计从 startTime[i] 开始到 endTime[i] 结束，报酬为 profit[i]。\n给你一份兼职工作表，包含开始时间 startTime，结束时间 endTime 和预计报酬 profit 三个数组，请你计算并返回可以获得的最大报酬。\n注意，时间上出现重叠的 2 份工作不能同时进行。\n如果你选择的工作在时间 X 结束，那么你可以立刻进行在时间 X 开始的下一份工作。\n示例示例1.\n输入：startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]\n输出：120\n解释：\n我们选出第 1 份和第 4 份工作， \n时间范围是 [1-3]+[3-6]，共获得报酬 120 = 50 + 70。\n\n示例2.\n输入：startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]\n输出：150\n解释：\n我们选择第 1，4，5 份工作。 \n共获得报酬 150 = 20 + 70 + 60。\n\n示例3.\n输入：startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]\n输出：6\n\n解题思路\n施工\n\n代码参考class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -&gt; int:\n        jobs &#x3D; sorted(zip(startTime, endTime, profit), key &#x3D; lambda x: x[1])\n        dp &#x3D; [[0, 0]]\n        for s, e, p in jobs:\n            i &#x3D; bisect.bisect(dp, [s + 1]) - 1\n            if dp[i][1] + p &gt; dp[-1][1]:\n                dp.append([e, dp[i][1] + p])\n        return dp[-1][1]\n\n","slug":"LeetCode第1235题：规划兼职工作","date":"2022-10-21T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,动态规划,Like","author_index":"秋水"},{"id":"8ad1a84233291295facf5927e913e5d3","title":"LeetCode第901题：股票价格跨度","content":"901.股票价格跨度题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n设计\nMed\n单调栈\nYes\n\n\n题目要求编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。\n今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。\n例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。\n示例示例1.\n输入：[&quot;StockSpanner&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[],[100],[80],[60],[70],[60],[75],[85]]\n输出：[null,1,1,1,2,1,4,6]\n解释：\n首先，初始化 S = StockSpanner()，然后：\nS.next(100) 被调用并返回 1，\nS.next(80) 被调用并返回 1，\nS.next(60) 被调用并返回 1，\nS.next(70) 被调用并返回 2，\nS.next(60) 被调用并返回 1，\nS.next(75) 被调用并返回 4，\nS.next(85) 被调用并返回 6。\n\n注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格\n(包括今天的价格 75) 小于或等于今天的价格。\n复制示例输入\n\n解题思路\n首先在inint初始化一个单调栈，用于维护\n维护一个栈顶到栈底递减的单调栈，栈中存放金钱和跨度，但金钱大于栈顶元素就出栈并且跨度加一，直到栈为空或者遇到小于栈中元素时停止循环\n\n代码参考class StockSpanner:\n    def __init__(self):\n        self.stack &#x3D; []\n\n\n    def next(self, price: int) -&gt; int:\n        cut &#x3D; 1\n        while self.stack and self.stack[-1][0] &lt;&#x3D; price:\n            cut +&#x3D; self.stack.pop()[1]\n        self.stack.append((price, cut))\n        return cut\n\n\n# Your StockSpanner object will be instantiated and called as such:\n# obj &#x3D; StockSpanner()\n# param_1 &#x3D; obj.next(price)\n\n","slug":"LeetCode第901题：股票价格跨度","date":"2022-10-20T16:00:00.000Z","categories_index":"设计","tags_index":"力扣,Like,单调栈","author_index":"秋水"},{"id":"cabc7f1e9b78e29c3cc491c17b3d2d87","title":"LeetCode第27题：移除元素","content":"27.移除元素题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n数组\nNo\n\n\n题目要求给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n说明:\n为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以引用方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\nint len &#x3D; removeElement(nums, val);\n\n&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。\n&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\nfor (int i &#x3D; 0; i &lt; len; i++) &#123;\n    print(nums[i]);\n&#125;\n\n\n示例示例1.\n输入：nums = [3,2,2,3], val = 3\n输出：2, nums = [2,2]\n解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n\n示例2.\n输入：nums = [0,1,2,2,3,0,4,2], val = 2\n输出：5, nums = [0,1,4,0,3]\n解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n\n解题思路\n遍历数组pop元素\n\n代码参考class Solution:\n    def removeElement(self, nums: List[int], val: int) -&gt; int:\n        i &#x3D; 0\n        while i !&#x3D; len(nums):\n            if nums[i] &#x3D;&#x3D; val:\n                nums.pop(i)\n                continue\n            i +&#x3D; 1\n        return len(nums)\n\n","slug":"LeetCode第27题：移除元素","date":"2022-10-19T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,数组","author_index":"秋水"},{"id":"65ae1f33790760647c8e3c5fb1186386","title":"LeetCode第46题：全排列","content":"46.全排列题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n回溯，dfs\nYes\n\n\n题目要求给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。\n示例示例1.\n输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n示例2.\n输入：nums = [0,1]\n输出：[[0,1],[1,0]]\n\n示例3.\n输入：nums = [1]\n输出：[[1]]\n\n解题思路\n类似求排列组合的第一时间应当想到使用回溯算法\n但是由于输入规格以及时间复杂的考虑，要进行适当的剪枝\n\n代码参考class Solution:\n    def permute(self, nums: List[int]) -&gt; List[List[int]]:\n        def dfs(nums, path, depth, res, used, size):\n            if depth &#x3D;&#x3D; size:\n                res.append(path[:]) #进行一个copy的操作\n                return\n            for i in range(size):\n                if not used[i]: # 剪枝\n                    used[i] &#x3D; True\n                    path.append(nums[i])\n                    dfs(nums, path, depth + 1, res, used, size)\n                    used[i] &#x3D; False\n                    path.pop()\n        size &#x3D; len(nums)\n        path &#x3D; []\n        depth &#x3D; 0\n        res &#x3D; []\n        used &#x3D; [False for _ in range(size)]\n        dfs(nums, path, depth, res, used, size)\n        # num传入的要求排列的数组，path是回溯时产生的排列数组，深度时来判断是否到达了底部要进行返回，used时判断当前元素是否用过进行剪枝，size时输入数组大小\n        return res\n\n","slug":"LeetCode第46题：全排列","date":"2022-10-19T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,回溯,dfs","author_index":"秋水"},{"id":"050abb7935ed5ccefb3818c06b82ad20","title":"LeetCode第34题：字符串相乘","content":"34.字符串相乘题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n字符串\nNo\n\n\n题目要求给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。\n注意： 不能使用任何内置的 BigInteger 库或直接将输入转换为整数。\n示例示例1.\n输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;\n输出: &quot;6&quot;\n\n示例2.\n输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;\n输出: &quot;56088&quot;\n\n解题思路\n首先进行一个简单的判断，若任意一个元素时&#39;0&#39;则直接返回0\n然后建立一个存储相乘结果的表，长度就为两字符串长度之和，其结果不会超过这个数\n然后进行模拟乘法，把结果存到定义的数组里\n最后模拟进位，然后判断数组头是否为0，为0就切片去掉，只用判断数组头是因为给定的长度中至多会出现一个前导0\n\n代码参考class Solution:\n    def multiply(self, num1: str, num2: str) -&gt; str:\n        if num1 &#x3D;&#x3D; &#39;0&#39; or num2 &#x3D;&#x3D; &#39;0&#39;:\n            return &#39;0&#39;\n        temp &#x3D; [0 for _ in range(len(num1) + len(num2))]\n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                temp[i+j+1] +&#x3D; int(num1[i]) * int(num2[j])\n        for i in range(len(temp)-1, -1, -1):\n            temp[i-1] +&#x3D; temp[i] &#x2F;&#x2F; 10\n            temp[i] &#x3D; temp[i] % 10\n        if temp[0] &#x3D;&#x3D; 0:\n            temp &#x3D; temp[1:]\n        return &#39;&#39;.join(str(i) for i in temp)\n\n","slug":"LeetCode第34题：字符串相乘","date":"2022-10-19T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,字符串","author_index":"秋水"},{"id":"ddc869d01de5d4c0cf61eb64cfb85599","title":"LeetCode第58题：最后一个单词的长度","content":"46.全排列题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n字符串\nNo\n\n\n题目要求给你一个字符串s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个单词的长度。\n单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。\n示例示例1.\n输入：s = &quot;Hello World&quot;\n输出：5\n解释：最后一个单词是“World”，长度为5。\n\n示例2.\n输入：s = &quot;   fly me   to   the moon  &quot;\n输出：4\n解释：最后一个单词是“moon”，长度为4。\n\n示例3.\n输入：s = &quot;luffy is still joyboy&quot;\n输出：6\n解释：最后一个单词是长度为6的“joyboy”。\n\n解题思路\n字符串分割后取最后一个元素的长度\n\n代码参考class Solution:\n    def lengthOfLastWord(self, s: str) -&gt; int:\n        return len(s.split()[-1])\n\n","slug":"LeetCode第58题：最后一个单词的长度","date":"2022-10-19T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,字符串","author_index":"秋水"},{"id":"2a866bc85decb0166a954516d6049013","title":"LeetCode第779题：第k个语法符号","content":"779.第k个语法符号题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n递归\nYes\n\n\n题目要求我们构建了一个包含 n 行( 索引从 1  开始 )的表。首先在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。\n\n例如，对于 n = 3 ，第 1 行是 0 ，第 2 行是 01 ，第3行是 0110 。\n\n给定行数 n 和序数 k，返回第 n 行中第 k 个字符。（ k 从索引 1 开始）\n示例示例1.\n输入：n = 1, k = 1\n输出: 0\n解释: 第一行：0\n\n示例2.\n输入: n = 2, k = 1\n输出: 0\n解释: \n第一行: 0 \n第二行: 01 \n\n示例3.\n输入: n = 2, k = 2\n输出: 1\n解释:\n第一行: 0\n第二行: 01\n\n解题思路\n首先由输入规格我们可知字符串的长度为2的n-1次方，使用比不可能创建字符串去索引\n其次观察答案样式，可知在当前f(n)的字符串当k为偶数时，与f(n-1)中的字符串中的k&#x2F;&#x2F;2下标元素时相反的，当k为奇数时则不相反\n例如：\nn &#x3D;&#x3D; 2： 01\nn &#x3D;&#x3D; 3： 0110 \nn &#x3D;&#x3D; 4： 01101001\n偶数用斜体表示，奇数用粗体表示，可见奇数k时与n-1的元素对应不变，与偶数时正好相反，所以可以使用1-f(n, k) &#x3D;&#x3D; f(n - 1, k &#x2F;&#x2F; 2)\n\n代码参考class Solution:\n    def kthGrammar(self, n: int, k: int) -&gt; int:\n        if n &#x3D;&#x3D; 1:\n            return 0\n        return self.kthGrammar(n - 1, (k + 1) &#x2F;&#x2F; 2) if k % 2 else 1 - self.kthGrammar(n - 1, k &#x2F;&#x2F; 2)\n","slug":"LeetCode第779题：第k个语法符号","date":"2022-10-19T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,递归","author_index":"秋水"},{"id":"2f29bc9f36642c684480423dd6e71762","title":"LeetCode第1012题：至少有1为重复的数字","content":"1012.至少有1为重复的数字题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nHard\n数位dp\nYes\n\n\n题目要求给定正整数 n，返回在 [1, n] 范围内具有 至少 1 位 重复数字的正整数的个数。\n示例示例1.\n输入：n = 20\n输出：1\n解释：具有至少 1 位重复数字的正数（&lt;= 20）只有 11 。\n\n示例2.\n输入：n = 100\n输出：10\n解释：具有至少 1 位重复数字的正数（&lt;= 100）有 11，22，33，44，55，66，77，88，99 和 100 \n\n示例3.\n输入：n = 1000\n输出：262\n\n解题思路\n使用模板（还在施工\n\n代码参考class Solution:\n    def numDupDigitsAtMostN(self, n: int) -&gt; int:\n        # 数位DP模板\n        s &#x3D; str(n)\n        \n        @lru_cache\n        def f(i: int, mask: int, is_limit: bool, is_num: bool) -&gt; int:\n            if i &#x3D;&#x3D; len(s):\n                return int(is_num)\n            res &#x3D; 0\n            if not is_num: # 选择跳过\n                res &#x3D; f(i + 1, mask, False, False)\n            up &#x3D; int(s[i]) if is_limit else 9\n            # 枚举要填的数字，枚举范围取决于is_limit和is_num\n            for d in range(1 - int(is_num), up + 1):\n                if mask &gt;&gt; d &amp; 1 &#x3D;&#x3D; 0: #mask里没有d\n                    res +&#x3D; f(i + 1, mask | (1 &lt;&lt; d), is_limit and d &#x3D;&#x3D; up, True)\n            return res\n        return n - f(0, 0, True, False)\n\n","slug":"LeetCode第1012题：至少有1为重复的数字","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,动态规划,数位dp,Like","author_index":"秋水"},{"id":"06da0c8cc991f9bc52c577bd89acffa5","title":"LeetCode第1700题：无法吃午餐的学生数量","content":"1700.无法吃午餐的学生数量题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n栈，模拟\nNo\n\n\n题目要求学校的自助午餐提供圆形和方形的三明治，分别用数字 0 和 1 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。\n餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 栈 里，每一轮：\n\n如果队列最前面的学生 喜欢 栈顶的三明治，那么会 拿走它 并离开队列。\n否则，这名学生会 放弃这个三明治 并回到队列的尾部。\n\n这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。\n给你两个整数数组 students 和 sandwiches，其中 sandwiches[i] 是栈里面第 i 个三明治的类型（i = 0 是栈的顶部）， students[j] 是初始队。列里第 j 名学生对三明治的喜好（j = 0 是队列的最开始位置）。请你返回无法吃午餐的学生数量。\n示例示例1.\n输入：students = [1,1,0,0], sandwiches = [0,1,0,1]\n输出：0 \n解释：\n- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [1,0,0,1]。\n- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [0,0,1,1]。\n- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [0,1,1]，三明治栈为 sandwiches = [1,0,1]。\n- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [1,1,0]。\n- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [1,0]，三明治栈为 sandwiches = [0,1]。\n- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [0,1]。\n- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [1]，三明治栈为 sandwiches = [1]。\n- 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = []，三明治栈为 sandwiches = []。\n所以所有学生都有三明治吃。\n\n示例2.\n输入：students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]\n输出：3 \n\n解题思路\n读懂题意进行模拟即可，第一个if判断如果只有一种学生但是有多种三明治，则直接退出循环，因为再学生为[1, 1, 1]但三明治为[0, 1, 1]时怎么排队都无法拿去第一个三明治\n第二个if模拟排队过程，出栈底元素再将他入栈，最后一个判断是当匹配条件的时候，学生拿走三明治然后计数加一\n最后返回长度减去计数即可，若是第一个学生和第一个三明治匹配就返回长度减去计数再减一，防止只剩最后一个学生没判断上\n\n代码参考class Solution:\n    def countStudents(self, students: List[int], sandwiches: List[int]) -&gt; int:\n        length &#x3D; len(students)\n        count &#x3D; 0\n        while len(students) &gt; 1:\n            if len(set(students)) &#x3D;&#x3D; 1 and students[0] !&#x3D; sandwiches[0]:\n                break\n            if students[0] !&#x3D; sandwiches[0]:\n                students.append(students.pop(0))\n                continue\n            else:\n                students.pop(0)\n                sandwiches.pop(0)\n                count +&#x3D; 1\n        return length - count if students[0] !&#x3D; sandwiches[0] else length - count - 1\n\n","slug":"LeetCode第1700题：无法吃午餐的学生数量","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,栈,模拟","author_index":"秋水"},{"id":"9eb1bd5b03774bfeca70051c02665fcc","title":"LeetCode第2373题：矩阵局部最大值","content":"2373.矩阵局部最大值题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n矩阵\nNo\n\n\n题目要求给你一个大小为 n x n 的整数矩阵 grid 。\n生成一个大小为 (n - 2) x (n - 2) 的整数矩阵  maxLocal ，并满足：\n\nmaxLocal[i][j] 等于 grid 中以 i + 1 行和 j + 1 列为中心的 3 x 3 矩阵中的 最大值 。换句话说，我们希望找出 grid 中每个 3 x 3 矩阵中的最大值。\n\n返回生成的矩阵。\n示例示例1.\n输入：grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]\n输出：[[9,9],[8,6]]\n解释：原矩阵和生成的矩阵如上图所示。\n注意，生成的矩阵中，每个值都对应 grid 中一个相接的 3 x 3 矩阵的最大值。\n\n示例2.\n输入：grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]\n输出：[[2,2,2],[2,2,2],[2,2,2]]\n解释：注意，2 包含在 grid 中每个 3 x 3 的矩阵中。\n\n解题思路\n用双重循环来判断每三行每三列的最大值，然后存储到左上角，这部分区域再也不会用到\n使用pop来保证最后返回的矩阵规格合法且省去切片是copy的时间\n\n代码参考class Solution:\n    def largestLocal(self, grid: List[List[int]]) -&gt; List[List[int]]:\n        n &#x3D; len(grid)\n        for i in range(n - 2):\n            for j in range(n - 2):\n                grid[i][j] &#x3D; max(max(row[j: j + 3]) for row in grid[i: i + 3])\n            grid[i].pop()\n            grid[i].pop()\n        grid.pop()\n        grid.pop()\n        return grid\n\n","slug":"LeetCode第2373题：矩阵局部最大值","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,矩阵","author_index":"秋水"},{"id":"c02a0d58d02f45cdce74135318840401","title":"LeetCode第2374题：边积分最高的节点","content":"2374.边积分最高的节点题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n数组\nNo\n\n\n题目要求给你一个有向图，图中有 n 个节点，节点编号从 0 到 n - 1 ，其中每个节点都 恰有一条 出边。\n图由一个下标从 0 开始、长度为 n 的整数数组 edges 表示，其中 edges[i] 表示存在一条从节点 i 到节点 edges[i] 的 有向 边。\n节点 i 的 边积分 定义为：所有存在一条指向节点 i 的边的节点的 编号 总和。\n返回 边积分 最高的节点。如果多个节点的 边积分 相同，返回编号 最小 的那个。\n示例示例1.\n输入：edges = [1,0,0,0,0,7,7,5]\n输出：7\n解释：\n- 节点 1、2、3 和 4 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 + 3 + 4 = 10 。\n- 节点 0 有一条指向节点 1 的边，节点 1 的边积分等于 0 。\n- 节点 7 有一条指向节点 5 的边，节点 5 的边积分等于 7 。\n- 节点 5 和 6 都有指向节点 7 的边，节点 7 的边积分等于 5 + 6 = 11 。\n节点 7 的边积分最高，所以返回 7 。\n\n示例2.\n输入：edges = [2,0,0,2]\n输出：0\n解释：\n- 节点 1 和 2 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 = 3 。\n- 节点 0 和 3 都有指向节点 2 的边，节点 2 的边积分等于 0 + 3 = 3 。\n节点 0 和 2 的边积分都是 3 。由于节点 0 的编号更小，返回 0 。\n\n解题思路\n读懂题目，遍历边数组时同时遍历下标和值，因为最后查找时是按下标顺序，所以必然是索引值的最小值\n\n代码参考class Solution:\n    def edgeScore(self, edges: List[int]) -&gt; int:\n        tmp &#x3D; [0] * len(edges)\n        res &#x3D; 0\n        for i, j in enumerate(edges):\n            tmp[j] +&#x3D; i\n            if tmp[j] &gt; tmp[res] or (tmp[j] &#x3D;&#x3D; tmp[res] and j &lt; res):\n                res &#x3D; j\n        return res\n\n","slug":"LeetCode第2374题：边积分最高的节点","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,数组","author_index":"秋水"},{"id":"d14c45a1dbcb2674b71ebe2ea419cd16","title":"LeetCode第2375题：根据模式串构建最小数字","content":"2375.根据模式串构建最小数字题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n数位dp\nYes\n\n\n题目要求给你下标从 0 开始、长度为 n 的字符串 pattern ，它包含两种字符，&#39;I&#39; 表示 上升 ，&#39;D&#39; 表示 下降 。\n你需要构造一个下标从 0 开始长度为 n + 1 的字符串，且它要满足以下条件：\n\nnum 包含数字 &#39;1&#39; 到 &#39;9&#39; ，其中每个数字 至多 使用一次。\n如果 pattern[i] == &#39;I&#39; ，那么 num[i] &lt; num[i + 1] 。\n如果 pattern[i] == &#39;D&#39; ，那么 num[i] &gt; num[i + 1] 。\n\n你返回满足上述条件字典序 最小 的字符串 num。\n示例示例1.\n输入：pattern = &quot;IIIDIDDD&quot;\n输出：&quot;123549876&quot;\n解释：\n下标 0 ，1 ，2 和 4 处，我们需要使 num[i] &lt; num[i+1] 。\n下标 3 ，5 ，6 和 7 处，我们需要使 num[i] &gt; num[i+1] 。\n一些可能的 num 的值为 &quot;245639871&quot; ，&quot;135749862&quot; 和 &quot;123849765&quot; 。\n&quot;123549876&quot; 是满足条件最小的数字。\n注意，&quot;123414321&quot; 不是可行解因为数字 &#39;1&#39; 使用次数超过 1 次。\n\n示例2.\n输入：n = 5\n输出：5\n解释：1 到 5 所有整数都是特殊整数。 \n\n示例3.\n输入：pattern = &quot;DDD&quot;\n输出：&quot;4321&quot;\n解释：\n一些可能的 num 的值为 &quot;9876&quot; ，&quot;7321&quot; 和 &quot;8742&quot; 。\n&quot;4321&quot; 是满足条件最小的数字。\n\n解题思路\n先建立一个1到pattern长度加一的字符串，其值为:\n[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, ..., &#39;len(pattern) + 1&#39;]\n观察答案知只需要把模式串中的D的下标与其下标加一的切边给倒转即可\n\n代码参考class Solution:\n    def smallestNumber(self, pattern: str) -&gt; str:\n        n &#x3D; len(pattern)\n        res &#x3D; list(digits[1: n + 2])\n        i &#x3D; 0\n        while i &lt; n:\n            if pattern[i] &#x3D;&#x3D; &#39;I&#39;:\n                i +&#x3D; 1\n                continue\n            st &#x3D; i\n            i +&#x3D; 1\n            while i &lt; n and pattern[i] &#x3D;&#x3D; &#39;D&#39;:\n                i +&#x3D; 1\n            res[st: i + 1] &#x3D; res[st: i + 1][::-1]\n        return &#39;&#39;.join(res)\n\n","slug":"LeetCode第2375题：根据模式串构建最小数字","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,贪心","author_index":"秋水"},{"id":"3c1df83d6c4d033a66322b21ef2ea886","title":"LeetCode第2376题：统计特殊整数","content":"2376.统计特殊整数题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nHard\n数位dp\nYes\n\n\n题目要求如果一个正整数每一个数位都是 互不相同 的，我们称它是 特殊整数 。给你一个 正 整数 n ，请你返回区间 [1, n] 之间特殊整数的数目。\n示例示例1.\n输入：n = 20\n输出：19\n解释：1 到 20 之间所有整数除了 11 以外都是特殊整数。所以总共有 19 个特殊整数。\n\n示例2.\n输入：n = 5\n输出：5\n解释：1 到 5 所有整数都是特殊整数。 \n\n示例3.\n输入：n = 135\n输出：110\n解释：从 1 到 135 总共有 110 个整数是特殊整数。\n不特殊的部分数字为：22 ，114 和 131 。\n\n解题思路\n使用模板（还在施工\n\n代码参考class Solution:\n    def countSpecialNumbers(self, n: int) -&gt; int:\n        # 数位DP模板\n        s &#x3D; str(n)\n        \n        @lru_cache\n        def f(i: int, mask: int, is_limit: bool, is_num: bool) -&gt; int:\n            if i &#x3D;&#x3D; len(s):\n                return int(is_num)\n            res &#x3D; 0\n            if not is_num: # 选择跳过\n                res &#x3D; f(i + 1, mask, False, False)\n            up &#x3D; int(s[i]) if is_limit else 9\n            # 枚举要填的数字，枚举范围取决于is_limit和is_num\n            for d in range(1 - int(is_num), up + 1):\n                if mask &gt;&gt; d &amp; 1 &#x3D;&#x3D; 0: #mask里没有d\n                    res +&#x3D; f(i + 1, mask | (1 &lt;&lt; d), is_limit and d &#x3D;&#x3D; up, True)\n            return res\n        return f(0, 0, True, False)\n\n","slug":"LeetCode第2376题：统计特殊整数","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,动态规划,数位dp,Like","author_index":"秋水"},{"id":"889b01da9eb4b8005ed2590296364df0","title":"LeetCode第396题：旋转函数","content":"396.旋转函数题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n动态规划，数组\nYes\n\n\n题目要求给定一个长度为 n 的整数数组 nums 。\n假设 arrk 是数组 nums 顺时针旋转 k 个位置后的数组，我们定义 nums 的 旋转函数  F 为：\n\nF(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]\n\n返回 F(0), F(1), ..., F(n-1)中的最大值 。\n生成的测试用例让答案符合 32 位 整数。\n示例示例1.\n输入: nums = [4,3,2,6]\n输出: 26\n解释:\nF(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25\nF(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16\nF(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23\nF(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26\n所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26 。\n\n示例2.\n输入: nums = [100]\n输出: 0\n\n解题思路\n观察答案可知，我们先将F(0)求出存入数组，然后F(1)相当于加上了整个数组的和，再减去倒数i位的n倍，这个n为数组长度，即F(1) = F(0) + sum(nums) - len(nums) * nums[-1]\n\n代码参考class Solution:\n    def maxRotateFunction(self, nums: List[int]) -&gt; int:\n        if len(nums) &#x3D;&#x3D; 1:\n            return 0\n        s, n &#x3D; sum(nums), len(nums)\n        res &#x3D; [sum(idx * val for idx, val in enumerate(nums))]\n        for i in range(1, len(nums)):\n            res.append(res[i - 1] + s - n * nums[-i])\n        return max(res)","slug":"LeetCode第396题：旋转函数","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,动态规划,Like,数组","author_index":"秋水"},{"id":"abd31ef79b2cfb8b01bf4c9895fea23c","title":"LeetCode第33题：搜索旋转排序数组","content":"33.搜索旋转排序数组题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n二分查找\nYes\n\n\n题目要求整数数组 nums 按升序排列，数组中的值 互不相同 。\n在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1],..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1。\n你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\n示例示例1.\n输入：nums = [4,5,6,7,0,1,2], target = 0\n输出：4\n\n示例2.\n输入：nums = [4,5,6,7,0,1,2], target = 3\n输出：-1\n\n示例3.\n输入：nums = [1], target = 0\n输出：-1\n\n解题思路\n使用二分查找，因为二分查找时间复杂度为logn，但是要有序才能使用二分查找\n看题意可知此旋转的数组时一半一半有序，使用只需分左半边和右半边进行分类讨论\n\n代码参考class Solution:\n    def search(self, nums: List[int], target: int) -&gt; int:\n        l, r &#x3D; 0, len(nums) - 1\n        while l &lt;&#x3D; r:\n            mid &#x3D; (l + r) &#x2F;&#x2F; 2\n            if nums[mid] &#x3D;&#x3D; target:\n                return mid  \n            elif nums[l] &lt;&#x3D; nums[mid]:#左半边有序的情况\n                if target &gt;&#x3D; nums[l] and target &lt; nums[mid]:\n                    r &#x3D; mid - 1 #大了，右边界缩小\n                else:\n                    l &#x3D; mid + 1 #小了， 左边界放大\n            else:\n                if target &lt;&#x3D; nums[r] and target &gt; nums[mid]:#右半边有序的情况\n                    l &#x3D; mid + 1\n                else:\n                    r &#x3D; mid - 1\n        return -1\n\n","slug":"LeetCode第33题：搜索旋转排序数组","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,二分查找","author_index":"秋水"},{"id":"6bf19f9e1626f2ef77b3dc19b91f8698","title":"LeetCode第46题：旋转图像","content":"46.旋转图像题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n数组\nNo\n\n\n题目要求给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。\n你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。\n示例示例1.\n输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[[7,4,1],[8,5,2],[9,6,3]]\n\n示例2.\n输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n解题思路\n建立一个辅助数组进行交换，先取每列然后反转\n\n代码参考class Solution:\n    def rotate(self, matrix: List[List[int]]) -&gt; None:\n        &quot;&quot;&quot;\n        Do not return anything, modify matrix in-place instead.\n        &quot;&quot;&quot;\n        n &#x3D; len(matrix)\n        res &#x3D; [[] for _ in range(n)]\n        for i in range(n):\n            res[i] &#x3D; [matrix[j][i] for j in range(n)]\n        for i in range(len(matrix)):\n            matrix[i] &#x3D; res[i][::-1]\n","slug":"LeetCode第46题：旋转图像","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,数组","author_index":"秋水"},{"id":"adfd5027038714fb32b438d9a0748c32","title":"LeetCode第48题：旋转图像","content":"48.旋转图像题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n数组\nNo\n\n\n题目要求给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。\n你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。\n示例示例1.\n输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[[7,4,1],[8,5,2],[9,6,3]]\n\n示例2.\n输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n解题思路\n建立一个辅助数组进行交换，先取每列然后反转\n\n代码参考class Solution:\n    def rotate(self, matrix: List[List[int]]) -&gt; None:\n        &quot;&quot;&quot;\n        Do not return anything, modify matrix in-place instead.\n        &quot;&quot;&quot;\n        n &#x3D; len(matrix)\n        res &#x3D; [[] for _ in range(n)]\n        for i in range(n):\n            res[i] &#x3D; [matrix[j][i] for j in range(n)]\n        for i in range(len(matrix)):\n            matrix[i] &#x3D; res[i][::-1]\n","slug":"LeetCode第48题：旋转图像","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,数组","author_index":"秋水"},{"id":"c30798b33e66c8d20737c478b69704f2","title":"LeetCode第796题：旋转字符串","content":"796.旋转字符串题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n字符串\nNo\n\n\n题目要求给定两个字符串, s 和 goal。如果在若干次旋转操作之后，s 能变成 goal ，那么返回 true 。\ns 的 旋转操作 就是将 s 最左边的字符移动到最右边。\n\n例如, 若 s = &#39;abcde&#39;，在旋转一次之后结果就是&#39;bcdea&#39; 。\n\n示例示例1.\n输入: s = &quot;abcde&quot;, goal = &quot;cdeab&quot;\n输出: true\n\n示例2.\n输入: s = &quot;abcde&quot;, goal = &quot;abced&quot;\n输出: false \n\n解题思路\n将字符串首位拼接一次，即s*2，然后判断goal是否在这串中，若不在则必不能旋转成goal\n还要判断原串和目标串是否长度相同\n\n代码参考class Solution:\n    def rotateString(self, s: str, goal: str) -&gt; bool:\n        return True if goal in s*2 and len(goal) &#x3D;&#x3D; len(s) else False\n","slug":"LeetCode第796题：旋转字符串","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,字符串","author_index":"秋水"},{"id":"fa6eed31fec0f134d367ea17142dbc3e","title":"LeetCode第902题：最大为N的数字组合","content":"9902.最大为N的数字组合题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nHard\n数位dp\nYes\n\n\n题目要求给定一个按 非递减顺序 排列的数字数组digits。你可以用任意次数digits[i]来写的数字。例如，如果digits = [&#39;1&#39;,&#39;3&#39;,&#39;5&#39;]，我们可以写数字，如&#39;13&#39;, &#39;551&#39;, 和&#39;1351315&#39;。\n返回 可以生成的小于或等于给定整数 n 的正整数的个数 。\n示例示例1.\n输入：digits = [&quot;1&quot;,&quot;3&quot;,&quot;5&quot;,&quot;7&quot;], n = 100\n输出：20\n解释：\n可写出的 20 个数字是：\n1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.\n\n示例2.\n输入：digits = [&quot;1&quot;,&quot;4&quot;,&quot;9&quot;], n = 1000000000\n输出：29523\n解释：\n我们可以写 3 个一位数字，9 个两位数字，27 个三位数字，\n81 个四位数字，243 个五位数字，729 个六位数字，\n2187 个七位数字，6561 个八位数字和 19683 个九位数字。\n总共，可以使用D中的数字写出 29523 个整数。\n\n示例3.\n输入：digits = [&quot;7&quot;], n = 8\n输出：1\n\n解题思路\n使用模板（还在施工\n\n代码参考class Solution:\n    def atMostNGivenDigitSet(self, digits: List[str], n: int) -&gt; int:\n        s &#x3D; str(n)\n\n        @lru_cache\n        def f(i: int, is_limit: bool, is_num: bool) -&gt; int:\n            if i &#x3D;&#x3D; len(s):\n                return int(is_num)\n            res &#x3D; 0\n            if not is_num: # 选择跳过\n                res &#x3D; f(i + 1, False, False)\n            up &#x3D; s[i] if is_limit else &#39;9&#39;\n            # 枚举要填的数字，枚举范围取决于is_limit和is_num\n            for d in digits:\n                if d &gt; up: \n                    break #mask里没有d\n                res +&#x3D; f(i + 1, is_limit and d &#x3D;&#x3D; up, True)\n            return res\n        return f(0, True, False)\n\n","slug":"LeetCode第902题：最大为N的数字组合","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,动态规划,数位dp,Like","author_index":"秋水"},{"id":"18ba4601c07e45b1b8afaa7828c586ff","title":"LeetCode第x题：x","content":"2376.统计特殊整数题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nx\nx\nx\n\n\n题目要求示例示例1.\n输入：n = 20\n输出：19\n解释：1 到 20 之间所有整数除了 11 以外都是特殊整数。所以总共有 19 个特殊整数。\n\n示例2.\n输入：n = 5\n输出：5\n解释：1 到 5 所有整数都是特殊整数。 \n\n示例3.\n输入：n = 135\n输出：110\n解释：从 1 到 135 总共有 110 个整数是特殊整数。\n不特殊的部分数字为：22 ，114 和 131 。\n\n解题思路+ \n代码参考class Solution:\n    def smallestNumber(self, pattern: str) -&gt; str:\n        n &#x3D; len(pattern)\n        res &#x3D; list(digits[1: n + 2])\n        i &#x3D; 0\n        while i &lt; n:\n            if pattern[i] &#x3D;&#x3D; &#39;I&#39;:\n                i +&#x3D; 1\n                continue\n            st &#x3D; i\n            i +&#x3D; 1\n            while i &lt; n and pattern[i] &#x3D;&#x3D; &#39;D&#39;:\n                i +&#x3D; 1\n            res[st: i + 1] &#x3D; res[st: i + 1][::-1]\n        return &#39;&#39;.join(res)\n","slug":"LeetCode第x题：x","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣","author_index":"秋水"},{"id":"b846fdcd170df4cd2690cf94865d978d","title":"LeetCode第33题：搜索旋转排序数组 II","content":"33.搜索旋转排序数组  II题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n二分查找\nYes\n\n\n题目要求整数数组 nums 按升序排列，数组中的值 互不相同 。\n在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1],..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回true，否则返回 false。\n你必须尽可能减少整个操作步骤。\n示例示例1.\n输入：nums = [2,5,6,0,0,1,2], target = 0\n输出：true\n\n示例2.\n输入：nums = [2,5,6,0,0,1,2], target = 3\n输出：false\n\n解题思路\n与33题类似，但是因为可能出现重复元素，使用当中间与前后两端的l，r对应的值相同时要l+1和r-1来缩小范围确定查找区间\n\n代码参考class Solution:\n    def search(self, nums: List[int], target: int) -&gt; bool:\n        l, r &#x3D; 0, len(nums) - 1\n        while l &lt;&#x3D; r:\n            mid &#x3D; (l + r) &#x2F;&#x2F; 2\n            if nums[mid] &#x3D;&#x3D; target:\n                return True  \n            if nums[mid] &#x3D;&#x3D; nums[l] &#x3D;&#x3D; nums[r]:\n                l +&#x3D; 1\n                r -&#x3D; 1\n            elif nums[l] &lt;&#x3D; nums[mid]:#左半边有序的情况\n                if target &gt;&#x3D; nums[l] and target &lt; nums[mid]:\n                    r &#x3D; mid - 1 #大了，右边界缩小\n                else:\n                    l &#x3D; mid + 1 #小了， 左边界放大\n            else:\n                if target &lt;&#x3D; nums[r] and target &gt; nums[mid]:#右半边有序的情况\n                    l &#x3D; mid + 1\n                else:\n                    r &#x3D; mid - 1\n        return False\n\n","slug":"LeetCode第81题：搜索旋转排序数组 II","date":"2022-10-17T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,二分查找","author_index":"秋水"},{"id":"1598e1fbda62dcb3747af5504eee9b77","title":"LeetCode第14题：最长公共前缀","content":"14.最长公共前缀题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n字符串\nNo\n\n\n题目要求编写一个函数来查找字符串数组中的最长公共前缀。\n如果不存在公共前缀，返回空字符串 &quot;&quot;。\n示例示例1.\n输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]\n输出：&quot;fl&quot;\n\n示例2.\n输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]\n输出：&quot;&quot;\n解释：输入不存在公共前缀。\n\n解题思路\n将数组进行按着长度排序，然后利用最短的字符串的内容来匹配后面的字符串\n只要中途断掉一次就直接返回无需重复判断\n\n代码参考class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -&gt; str:\n        strs.sort(key&#x3D;lambda i:len(i))\n        res &#x3D; &#39;&#39;\n        for i in range(len(strs[0])):\n            for j in range(1, len(strs)):\n                if strs[j][i] !&#x3D; strs[0][i]:\n                    return res\n            res +&#x3D; strs[0][i]\n        return res\n\n","slug":"LeetCode第14题：最长公共前缀","date":"2022-10-16T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,字符串","author_index":"秋水"},{"id":"564a937d2cd48b1701248e7c56119651","title":"LeetCode第904题：水果成篮","content":"904.水果成篮题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n哈希表, 滑动串口\nYes\n\n\n题目要求你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。\n你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：\n\n你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。\n你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上恰好摘一个水果。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。\n一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。\n\n给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。\n示例示例1.\n输入：fruits = [1,2,1]\n输出：3\n解释：可以采摘全部 3 棵树。\n\n示例2.\n输入：fruits = [0,1,2,2]\n输出：3\n解释：可以采摘 [1,2,2] 这三棵树。\n如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。\n\n示例3.\n输入：fruits = [1,2,3,2,2]\n输出：4\n解释：可以采摘 [2,3,2,2] 这四棵树。\n如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。\n\n示例4.\n输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]\n输出：5\n解释：可以采摘 [1,2,1,1,2] 这五棵树。\n\n解题思路\n这种要求连续的，一般是维护一个动态的滑动窗口，定义两个指针来作为窗口长度\n然后因为只有两个篮子，只能采摘两种果实，可以定义一个哈希表来表示窗口中的水果的种类以及计数，顺便当种类大于2时判断窗口左侧要移动多少个单位\n最后定义一个结果变量来动态记录值，窗口的右侧减去左侧加上1就是当前水果篮中的最大值\n\n代码参考class Solution:\n    def totalFruit(self, fruits: List[int]) -&gt; int:\n        count, res, j &#x3D; Counter(), 0, 0\n        for i in range(len(fruits)):\n            count[fruits[i]] +&#x3D; 1\n            while len(count) &gt; 2:\n                tmp &#x3D; fruits[j]\n                count[tmp] -&#x3D; 1\n                if count[tmp] &#x3D;&#x3D; 0:\n                    count.pop(tmp)\n                j +&#x3D; 1\n            res &#x3D; max(res, i - j + 1)\n        return res # i是窗口右侧， j是窗口左侧\n\n","slug":"LeetCode第904题：水果成篮","date":"2022-10-16T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,滑动串口,哈希表","author_index":"秋水"},{"id":"61bb6f5cc8c2b354654a3924ef551bd8","title":"LeetCode第9题：回文数","content":"9.回文数题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n字符串\nNo\n\n\n题目要求给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n例如，121 是回文，而 123 不是。\n\n示例示例1.\n输入：x = 121\n输出：true\n\n示例2.\n输入：x = -121\n输出：false\n解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n\n示例3.\n输入：x = 10\n输出：false\n解释：从右向左读, 为 01 。因此它不是一个回文数。\n\n解题思路\n正着读等于反着读\n\n代码参考class Solution:\n    def isPalindrome(self, x: int) -&gt; bool:\n        return (&#39;&#39;.join(list(str(x)))) &#x3D;&#x3D; (&#39;&#39;.join(list(str(x))[::-1]))\n\n","slug":"LeetCode第9题：回文数","date":"2022-10-16T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,字符串","author_index":"秋水"},{"id":"d8a096fe7b0db144c234f1fea1d80896","title":"LeetCode第856题：括号的分数","content":"856.括号的分数题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n栈, 字符串\nYes\n\n\n题目要求给定一组n给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：\n\n() 得 1 分。\nAB 得 A + B 分，其中 A 和 B 是平衡括号字符串。\n(A) 得 2 * A 分，其中 A 是平衡括号字符串。\n\n示例示例1.\n输入： &quot;()&quot;\n输出： 1\n\n示例2.\n输入： &quot;(())&quot;\n输出： 2\n\n示例3.\n输入： &quot;()()&quot;\n输出： 2\n \n\n示例4.\n输入： &quot;(()(()))&quot;\n输出： 6\n\n解题思路\n由于这种类似与用字符串实现加减乘除的模板，那就很容易想到使用栈来解决\n其次看给出的限定条件，可以知道条件1，条件2是最简单的条件，条件1就直接赋值为1，条件2就直接使用+&#x3D;来计算同时也要考虑一下边界就好了\n条件三如果一个一个情况考虑那就太复杂了，可以使用位运算，定义一个深度的变量，深度多深就左移多少位，刚刚好实现了乘2\n\n代码参考class Solution:\n    def scoreOfParentheses(self, s: str) -&gt; int:\n        res, deep &#x3D; 0, 0\n        for i, v in enumerate(s):\n            deep +&#x3D; 1 if v &#x3D;&#x3D; &#39;(&#39; else -1\n            if v &#x3D;&#x3D; &#39;)&#39; and s[i-1] &#x3D;&#x3D; &#39;(&#39;:\n                res +&#x3D; 1 &lt;&lt; deep\n        return res\n\n","slug":"LeetCode第856题：括号的分数","date":"2022-10-15T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,字符串,栈","author_index":"秋水"},{"id":"fe174234794c3746e58194d2817c117d","title":"LeetCode第785题：判断二分图","content":"785.判断二分图题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n并查集\nYes\n\n\n题目要求存在一个无向图，图中有n个节点。其中每个节点都有一个介于0到n - 1之间的唯一编号。给你一个二维数组graph，其中graph[u]是一个节点数组，由节点u的邻接节点组成。形式上，对于graph[u]中的每个v，都存在一条位于节点u和节点v 之间的无向边。该无向图同时具有以下属性：\n示例示例1.\n输入：graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\n输出：false\n解释：不能将节点分割成两个独立的子集，以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。\n\n示例2.\n输入：graph = [[1,3],[0,2],[1,3],[0,2]]\n输出：true\n解释：可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;\n\n解题思路\n建立并查集找冲突，与第886题差不多，找到要被连接的节点包含自身时发生冲突\n\n代码参考class Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -&gt; bool:\n\t\tclass UnionFind:\n            def __init__(self, n: int):\n                self.fa &#x3D; list(range(n))\n                self.size &#x3D; [1] * n\n\n            def find(self, x: int) -&gt; int:\n                if self.fa[x] !&#x3D; x:\n                    self.fa[x] &#x3D; self.find(self.fa[x])\n                return self.fa[x]\n\n            def union(self, x: int, y: int) -&gt; None:\n                fx, fy &#x3D; self.find(x), self.find(y)\n                if fx &#x3D;&#x3D; fy:\n                    return\n                if self.size[fx] &lt; self.size[fy]:\n                    fx, fy &#x3D; fy, fx\n                self.size[fx] +&#x3D; self.size[fy]\n                self.fa[fy] &#x3D; fx\n\n            def is_connected(self, x: int, y: int) -&gt; bool:\n                return self.find(x) &#x3D;&#x3D; self.find(y)\n\n        n &#x3D; len(graph)\n        uf &#x3D; UnionFind(n)\n        for x, nodes in enumerate(graph):\n            for y in nodes:\n                uf.union(nodes[0], y)\n                if uf.is_connected(x, y):\n                    return False\n        return True\n\n","slug":"LeetCode第785题：判断二分图","date":"2022-10-15T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,并查集","author_index":"秋水"},{"id":"59bc9b003b7228540fe2343582c95687","title":"LeetCode第886题：可能的二分法","content":"886.可能的二分法题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n并查集\nYes\n\n\n题目要求给定一组n人(编号为1, 2, ..., n), 我们想把每个人分进任意大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。\n给定整数n和数组dislikes，其中dislikes[i] = [ai, bi]，表示不允许将编号为ai和bi的人归入同一组。当可以用这种方法将所有人分进两组时，返回true；否则返回false。\n示例示例1.\n输入：n = 4, dislikes = [[1,2],[1,3],[2,4]]\n输出：true\n解释：group1 [1,4], group2 [2,3]\n\n示例2.\n输入：n = 3, dislikes = [[1,2],[1,3],[2,3]]\n输出：false\n\n示例3.\n输入：n = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]\n输出：false\n\n解题思路\n先建立一个邻接矩阵来代表每个人不喜欢的人\n然后建立一个并查集，因为只有两组，所以某个人不喜欢的人一定会在一个集合内\n最后我们使用建立的并查集进行连接，如果某个人不喜欢的人和他自身连接了就证明这组关系是有冲突的，不存在这样的二分组\n使用并查集的模板\n\n代码参考class Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -&gt; bool:\n\t\t# UnionFind类为并查集的模板\n        class UnionFind:\n            def __init__(self, n: int):\n                self.fa &#x3D; list(range(n))\n                self.size &#x3D; [1] * n\n\t\t\t\n\t\t\t# 路径压缩\n            def find(self, x: int) -&gt; int:\n                if self.fa[x] !&#x3D; x:\n                    self.fa[x] &#x3D; self.find(self.fa[x])\n                return self.fa[x]\n\n            def union(self, x: int, y: int) -&gt; None:\n                fx, fy &#x3D; self.find(x), self.find(y)\n                if fx &#x3D;&#x3D; fy:\n                    return\n                if self.size[fx] &lt; self.size[fy]:\n                    fx, fy &#x3D; fy, fx\n                self.size[fx] +&#x3D; self.size[fy]\n                self.fa[fy] &#x3D; fx\n\n            def is_connected(self, x: int, y: int) -&gt; bool:\n                return self.find(x) &#x3D;&#x3D; self.find(y)\n\n        diss &#x3D; [[] for _ in range(n)]\n        for x, y in dislikes:\n            diss[x - 1].append(y - 1)\n            diss[y - 1].append(x - 1)\n        uf &#x3D; UnionFind(n)\n        for x, nodes in enumerate(diss):\n            for y in nodes:\n                uf.union(nodes[0], y) # 处理每个人不喜欢的人的父节点\n                if uf.is_connected(x, y): # 处理过程中发现冲突直接返回\n                    return False\n        return True\n\n","slug":"LeetCode第886题：可能的二分法","date":"2022-10-15T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,并查集","author_index":"秋水"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"NOTHING!!(后续跟新print(&quot;hello world&quot;)\n","slug":"hello-world","date":"2022-10-15T02:41:39.690Z","categories_index":"","tags_index":"","author_index":"秋水"},{"id":"c0524bc960f43aa892c6edbb08789fd2","title":"LeetCode第107题：二叉树的层序遍历 II","content":"107.二叉树的层序遍历 II题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n树,BFS\nYes\n\n\n题目要求给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）。\n示例示例1.\n输入：root = [3,9,20,null,null,15,7]\n输出：[[15,7],[9,20],[3]]\n\n解题思路\n利用树的BFS模板，得到结果列表反转即可\n\n代码参考class Solution:\n    def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]:\n        if not root:\n            return []\n        temp_res &#x3D; [root]\n        res &#x3D; []\n        while temp_res:\n            res.append([i.val for i in temp_res])\n            next_level &#x3D; []\n            for i in temp_res:\n                if i.left:\n                    next_level.append(i.left)\n                if i.right:\n                    next_level.append(i.right)\n            temp_res &#x3D; next_level\n\t\t# 以上为树的广度搜索的模板\n        res.reverse()\n        return res\n\n","slug":"LeetCode第107题：二叉树的层序遍历 II","date":"2022-10-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,树,BFS","author_index":"秋水"},{"id":"3f9b149edda744a0462c85c999c4b231","title":"LeetCode第1441题：用栈操作构建数组","content":"1441.用栈操作构建数组题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n栈,模拟\nNo\n\n\n题目要求给你一个数组 target 和一个整数 n。每次迭代，需要从  list = [1, 2, 3,..., n]中依次读取一个数字。请使用下述操作来构建目标数组 target ：\n\n&quot;Push&quot;：从 list 中读取一个新元素， 并将其推入数组中。\n&quot;Pop&quot;：删除数组中的最后一个元素。\n如果目标数组构建完成，就停止读取更多元素。\n\n题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。请返回构建目标数组所用的操作序列。如果存在多个可行方案，返回任一即可。\n示例示例1.\n输入：target = [1,3], n = 3\n输出：[&quot;Push&quot;,&quot;Push&quot;,&quot;Pop&quot;,&quot;Push&quot;]\n解释： \n读取 1 并自动推入数组 -&gt; [1]\n读取 2 并自动推入数组，然后删除它 -&gt; [1]\n读取 3 并自动推入数组 -&gt; [1,3]\n\n示例2.\n输入：target = [1,2,3], n = 3\n输出：[&quot;Push&quot;,&quot;Push&quot;,&quot;Push&quot;]\n\n示例3.\n**输入：**target = [1,2], n = 4\n**输出：**[&quot;Push&quot;,&quot;Push&quot;]\n**解释：**只需要读取前 2 个数字就可以停止。\n\n解题思路\n将target以字典形式存储，减少查找时间\n如果1-n中含target只需入栈“Push”即可，若不存在则先入“Push”再入“Pop”\n最后若max(target) &lt; n的话只用判断到target最大的值即可终止循环\n\n代码参考class Solution:\n\tdef buildArray(self, target: List[int], n: int) -&gt; List[str]:\n\t\ttar &#x3D; set(target)\n\t\tres &#x3D; []\n\t\tfor i in range(1, max(tar) + 1):\n\t\t\tres.append(&#39;Push&#39;)\n\t\t\tif i in tar:\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tres.append(&#39;Pop&#39;)\n\t\treturn res\n\n","slug":"LeetCode第1441题：用栈操作构建数组","date":"2022-10-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,栈,模拟","author_index":"秋水"},{"id":"2e71333626c3011cee190883801aa78f","title":"LeetCode第237题：删除链表中的节点","content":"237.删除链表中的节点题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n链表\nNo\n\n\n题目要求请编写一个函数，用于 删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问 要被删除的节点 。\n题目数据保证需要删除的节点 不是末尾节点 。\n示例示例1.\n输入：head = [4,5,1,9], node = 5\n输出：[4,1,9]\n解释：指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9\n\n示例2.\n输入：head = [4,5,1,9], node = 1\n输出：[4,5,9]\n解释：指定链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9\n\n解题思路\n由于我们不无法获取链表的头，所以编写函数需返回任何值\n我们无法获取头，也就是说我们无法对要删除的链表的前驱进行操作\n我们只需要将要删除的节点的后继的值覆盖删除节点的值\n然后将链表的倒数二个节点的后继置空，就完成了删除节点的操作\n\n代码参考#\n# @lc app&#x3D;leetcode.cn id&#x3D;237 lang&#x3D;python3\n#\n# [237] 删除链表中的节点\n#\n\n# @lc code&#x3D;start\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val &#x3D; x\n#         self.next &#x3D; None\n\nclass Solution:\n\tdef deleteNode(self, node):\n\t\t&quot;&quot;&quot;\n\t\t:type node: ListNode\n\t\t:rtype: void Do not return anything, modify node in-place instead.\n\t\t&quot;&quot;&quot;\n\t\tnode1 &#x3D; node\n\t\twhile node.next:\n\t\t\tnode.val &#x3D; node.next.val\n\t\t\tif node.next.next:\n\t\t\t\tnode &#x3D; node.next\n\t\t\telse:\n\t\t\t\tnode.next &#x3D; None\n# @lc code&#x3D;end\n\n","slug":"LeetCode第237题：删除链表中的节点","date":"2022-10-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,链表","author_index":"秋水"},{"id":"91986e7de18a1f0d056c15eb6d3ad084","title":"LeetCode第575题：分糖果","content":"575.分糖果题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEesy\n脑筋急转弯\nNo\n\n\n题目要求 Alice 有 n 枚糖，其中第 i 枚糖的类型为 candyType[i] 。Alice 注意到她的体重正在增长，所以前去拜访了一位医生。\n医生建议 Alice 要少摄入糖分，只吃掉她所有糖的 n / 2 即可（n 是一个偶数）。Alice 非常喜欢这些糖，她想要在遵循医生建议的情况下，尽可能吃到最多不同种类的糖。\n给你一个长度为 n 的整数数组 candyType ，返回： Alice 在仅吃掉 n / 2 枚糖的情况下，可以吃到糖的最多种类数。\n示例示例1.\n输入：candyType = [1,1,2,2,3,3]\n输出：3\n解释：Alice 只能吃 6 / 2 = 3 枚糖，由于只有 3 种糖，她可以每种吃一枚。\n\n示例2.\n输入：candyType = [1,1,2,3]\n输出：2\n解释：Alice 只能吃 4 / 2 = 2 枚糖，不管她选择吃的种类是 [1,2]、[1,3] 还是 [2,3]，她只能吃到两种不同类的糖。\n\n示例3.\n输入：candyType = [6,6,6,6]\n输出：1\n解释：Alice 只能吃 4 / 2 = 2 枚糖，尽管她能吃 2 枚，但只能吃到 1 种糖。\n\n解题思路\n只需考虑两张极端思路即可得出答案\nAlice最多能吃len(candyType)的一半或者元素都相同则怎么吃都是一种\n最后只需判断是是candyType的长度一半大还是candyType的字典长度大即可\n\n代码参考class Solution:\n    def distributeCandies(self, candyType: List[int]) -&gt; int:\n        return len(candyType) &#x2F;&#x2F; 2 if len(set(candyType)) &gt; len(candyType) &#x2F;&#x2F; 2 else len(set(candyType))\n\n","slug":"LeetCode第575题：分糖果","date":"2022-10-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,脑筋急转弯","author_index":"秋水"},{"id":"21e1d52c3b2ce6bf6d44dddedefce323","title":"LeetCode第61题：旋转链表","content":"61.旋转链表题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n链表\nYes\n\n\n题目要求给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\n示例示例1.\n输入：head = [1,2,3,4,5], k = 2\n输出：[4,5,1,2,3]\n\n示例2.\n输入：head = [0,1,2], k = 4\n输出：[2,0,1]\n\n解题思路\n这种旋转的思路都大致相同，将两个相同的链表连接，然后再减去多余步数，即使答案\n例如示例二可变为：0-&gt;1-&gt;2-&gt;0-&gt;1-&gt;2，然后4是大于自身3的长度即用k去取余长度即使真正的步数，真正的步数永远不会大于两倍的lenght，所以只要在遍历一遍然后用长度减去真正的步数即使答案所求链表\n\n代码参考# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val&#x3D;0, next&#x3D;None):\n#         self.val &#x3D; val\n#         self.next &#x3D; next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:\n        if not head or not head.next or k &#x3D;&#x3D; 0:\n            return head\n        node &#x3D; ListNode(0)\n        node.next &#x3D; head\n        p1 &#x3D; node\n        lenght &#x3D; 0\n        while p1.next:\n            lenght +&#x3D; 1\n            p1 &#x3D; p1.next\n        if k % lenght &#x3D;&#x3D; 0:\n            return head\n        p1.next &#x3D; head\n        p1 &#x3D; node\n        i &#x3D; lenght - (k % lenght)\n        while i:\n            p1 &#x3D; p1.next\n            i -&#x3D; 1\n        result &#x3D; ListNode(0)\n        result.next &#x3D; p1.next\n        p1.next &#x3D; None\n        return result.next\n\n","slug":"LeetCode第61题：旋转链表","date":"2022-10-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,链表","author_index":"秋水"},{"id":"cecf4faf8156d8be7b73bb8270261e34","title":"LeetCode第64题：最小路径和","content":"64.最小路径和题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n动态规划\nYes\n\n\n题目要求给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n说明：每次只能向下或者向右移动一步。\n示例示例1.\n输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\n输出：7\n解释：因为路径 1→3→1→1→1 的总和最小。\n\n解题思路\n这种步步要精打细算很容易想到要求贪心算法或者动态规划\n但是贪心算法可能陷入局部最优所以采用动态规划\n先计算边缘格子的移动Cost，然后再利用双重循环的最小Cost来判断是往右还是往下走\n\n代码参考class Solution:\n    def minPathSum(self, grid: List[List[int]]) -&gt; int:\n        m, n &#x3D; len(grid), len(grid[0])\n        dp &#x3D; [[0] * n for _ in range(m)]\n        dp[0][0] &#x3D; grid[0][0]\n        for i in range(1, m):\n            dp[i][0] &#x3D; dp[i-1][0] + grid[i][0]\n        for j in range(1, n):\n            dp[0][j] &#x3D; dp[0][j-1] + grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] &#x3D; min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        return dp[m-1][n-1]\n\n","slug":"LeetCode第64题：最小路径和","date":"2022-10-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,动态规划,Like","author_index":"秋水"}]