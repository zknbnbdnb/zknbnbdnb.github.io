[{"id":"1598e1fbda62dcb3747af5504eee9b77","title":"LeetCode第14题：最长公共前缀","content":"14.最长公共前缀题目信息Q\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n字符串\nNo\n\n\n题目要求编写一个函数来查找字符串数组中的最长公共前缀。\n如果不存在公共前缀，返回空字符串 &quot;&quot;。\n示例示例1.\n输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]\n输出：&quot;fl&quot;\n\n示例2.\n输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]\n输出：&quot;&quot;\n解释：输入不存在公共前缀。\n\n解题思路\n将数组进行按着长度排序，然后利用最短的字符串的内容来匹配后面的字符串\n只要中途断掉一次就直接返回无需重复判断\n\n代码参考class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -&gt; str:\n        strs.sort(key&#x3D;lambda i:len(i))\n        res &#x3D; &#39;&#39;\n        for i in range(len(strs[0])):\n            for j in range(1, len(strs)):\n                if strs[j][i] !&#x3D; strs[0][i]:\n                    return res\n            res +&#x3D; strs[0][i]\n        return res\n\n","slug":"LeetCode第14题：最长公共前缀","date":"2022-10-16T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,字符串","author_index":"秋水"},{"id":"59bc9b003b7228540fe2343582c95687","title":"LeetCode第886题：可能的二分法","content":"886.可能的二分法题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n并查集\nYes\n\n\n题目要求给定一组n人(编号为1, 2, ..., n), 我们想把每个人分进任意大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。\n给定整数n和数组dislikes，其中dislikes[i] = [ai, bi]，表示不允许将编号为ai和bi的人归入同一组。当可以用这种方法将所有人分进两组时，返回true；否则返回false。\n示例示例1.\n输入：n = 4, dislikes = [[1,2],[1,3],[2,4]]\n输出：true\n解释：group1 [1,4], group2 [2,3]\n\n示例2.\n输入：n = 3, dislikes = [[1,2],[1,3],[2,3]]\n输出：false\n\n示例3.\n输入：n = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]\n输出：false\n\n解题思路\n先建立一个邻接矩阵来代表每个人不喜欢的人\n然后建立一个并查集，因为只有两组，所以某个人不喜欢的人一定会在一个集合内\n最后我们使用建立的并查集进行连接，如果某个人不喜欢的人和他自身连接了就证明这组关系是有冲突的，不存在这样的二分组\n使用并查集的模板\n\n代码参考class Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -&gt; bool:\n\t\t# UnionFind类为并查集的模板\n        class UnionFind:\n            def __init__(self, n: int):\n                self.fa &#x3D; list(range(n))\n                self.size &#x3D; [1] * n\n\t\t\t\n\t\t\t# 路径压缩\n            def find(self, x: int) -&gt; int:\n                if self.fa[x] !&#x3D; x:\n                    self.fa[x] &#x3D; self.find(self.fa[x])\n                return self.fa[x]\n\n            def union(self, x: int, y: int) -&gt; None:\n                fx, fy &#x3D; self.find(x), self.find(y)\n                if fx &#x3D;&#x3D; fy:\n                    return\n                if self.size[fx] &lt; self.size[fy]:\n                    fx, fy &#x3D; fy, fx\n                self.size[fx] +&#x3D; self.size[fy]\n                self.fa[fy] &#x3D; fx\n\n            def is_connected(self, x: int, y: int) -&gt; bool:\n                return self.find(x) &#x3D;&#x3D; self.find(y)\n\n        diss &#x3D; [[] for _ in range(n)]\n        for x, y in dislikes:\n            diss[x - 1].append(y - 1)\n            diss[y - 1].append(x - 1)\n        uf &#x3D; UnionFind(n)\n        for x, nodes in enumerate(diss):\n            for y in nodes:\n                uf.union(nodes[0], y) # 处理每个人不喜欢的人的父节点\n                if uf.is_connected(x, y): # 处理过程中发现冲突直接返回\n                    return False\n        return True\n\n","slug":"LeetCode第886题：可能的二分法","date":"2022-10-15T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,并查集","author_index":"秋水"},{"id":"cecf4faf8156d8be7b73bb8270261e34","title":"LeetCode第64题：最小路径和","content":"64.最小路径和题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n动态规划\nYes\n\n\n题目要求给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n说明：每次只能向下或者向右移动一步。\n示例示例1.\n输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\n输出：7\n解释：因为路径 1→3→1→1→1 的总和最小。\n\n解题思路\n这种步步要精打细算很容易想到要求贪心算法或者动态规划\n但是贪心算法可能陷入局部最优所以采用动态规划\n先计算边缘格子的移动Cost，然后再利用双重循环的最小Cost来判断是往右还是往下走\n\n代码参考class Solution:\n    def minPathSum(self, grid: List[List[int]]) -&gt; int:\n        m, n &#x3D; len(grid), len(grid[0])\n        dp &#x3D; [[0] * n for _ in range(m)]\n        dp[0][0] &#x3D; grid[0][0]\n        for i in range(1, m):\n            dp[i][0] &#x3D; dp[i-1][0] + grid[i][0]\n        for j in range(1, n):\n            dp[0][j] &#x3D; dp[0][j-1] + grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] &#x3D; min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        return dp[m-1][n-1]\n\n","slug":"LeetCode第64题：最小路径和","date":"2022-10-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,动态规划","author_index":"秋水"},{"id":"564a937d2cd48b1701248e7c56119651","title":"LeetCode第904题：水果成篮","content":"904.水果成篮题目信息Q\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n哈希表, 滑动串口\nYes\n\n\n题目要求你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。\n你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：\n\n你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。\n你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上恰好摘一个水果。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。\n一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。\n\n给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。\n示例示例1.\n输入：fruits = [1,2,1]\n输出：3\n解释：可以采摘全部 3 棵树。\n\n示例2.\n输入：fruits = [0,1,2,2]\n输出：3\n解释：可以采摘 [1,2,2] 这三棵树。\n如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。\n\n示例3.\n输入：fruits = [1,2,3,2,2]\n输出：4\n解释：可以采摘 [2,3,2,2] 这四棵树。\n如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。\n\n示例4.\n输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]\n输出：5\n解释：可以采摘 [1,2,1,1,2] 这五棵树。\n\n解题思路\n这种要求连续的，一般是维护一个动态的滑动窗口，定义两个指针来作为窗口长度\n然后因为只有两个篮子，只能采摘两种果实，可以定义一个哈希表来表示窗口中的水果的种类以及计数，顺便当种类大于2时判断窗口左侧要移动多少个单位\n最后定义一个结果变量来动态记录值，窗口的右侧减去左侧加上1就是当前水果篮中的最大值\n\n代码参考class Solution:\n    def totalFruit(self, fruits: List[int]) -&gt; int:\n        count, res, j &#x3D; Counter(), 0, 0\n        for i in range(len(fruits)):\n            count[fruits[i]] +&#x3D; 1\n            while len(count) &gt; 2:\n                tmp &#x3D; fruits[j]\n                count[tmp] -&#x3D; 1\n                if count[tmp] &#x3D;&#x3D; 0:\n                    count.pop(tmp)\n                j +&#x3D; 1\n            res &#x3D; max(res, i - j + 1)\n        return res # i是窗口右侧， j是窗口左侧\n\n","slug":"LeetCode第904题：水果成篮","date":"2022-10-16T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,滑动串口,哈希表","author_index":"秋水"},{"id":"61bb6f5cc8c2b354654a3924ef551bd8","title":"LeetCode第9题：回文数","content":"9.回文数题目信息Q\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n字符串\nNo\n\n\n题目要求给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。\n回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n例如，121 是回文，而 123 不是。\n\n示例示例1.\n输入：x = 121\n输出：true\n\n示例2.\n输入：x = -121\n输出：false\n解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n\n示例3.\n输入：x = 10\n输出：false\n解释：从右向左读, 为 01 。因此它不是一个回文数。\n\n解题思路\n正着读等于反着读\n\n代码参考class Solution:\n    def isPalindrome(self, x: int) -&gt; bool:\n        return (&#39;&#39;.join(list(str(x)))) &#x3D;&#x3D; (&#39;&#39;.join(list(str(x))[::-1]))\n\n","slug":"LeetCode第9题：回文数","date":"2022-10-16T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,字符串","author_index":"秋水"},{"id":"fe174234794c3746e58194d2817c117d","title":"LeetCode第785题：判断二分图","content":"785.判断二分图题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n并查集\nYes\n\n\n题目要求存在一个无向图，图中有n个节点。其中每个节点都有一个介于0到n - 1之间的唯一编号。给你一个二维数组graph，其中graph[u]是一个节点数组，由节点u的邻接节点组成。形式上，对于graph[u]中的每个v，都存在一条位于节点u和节点v 之间的无向边。该无向图同时具有以下属性：\n示例示例1.\n输入：graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\n输出：false\n解释：不能将节点分割成两个独立的子集，以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。\n\n示例2.\n输入：graph = [[1,3],[0,2],[1,3],[0,2]]\n输出：true\n解释：可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;\n\n解题思路\n建立并查集找冲突，与第886题差不多，找到要被连接的节点包含自身时发生冲突\n\n代码参考class Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -&gt; bool:\n\t\tclass UnionFind:\n            def __init__(self, n: int):\n                self.fa &#x3D; list(range(n))\n                self.size &#x3D; [1] * n\n\n            def find(self, x: int) -&gt; int:\n                if self.fa[x] !&#x3D; x:\n                    self.fa[x] &#x3D; self.find(self.fa[x])\n                return self.fa[x]\n\n            def union(self, x: int, y: int) -&gt; None:\n                fx, fy &#x3D; self.find(x), self.find(y)\n                if fx &#x3D;&#x3D; fy:\n                    return\n                if self.size[fx] &lt; self.size[fy]:\n                    fx, fy &#x3D; fy, fx\n                self.size[fx] +&#x3D; self.size[fy]\n                self.fa[fy] &#x3D; fx\n\n            def is_connected(self, x: int, y: int) -&gt; bool:\n                return self.find(x) &#x3D;&#x3D; self.find(y)\n\n        n &#x3D; len(graph)\n        uf &#x3D; UnionFind(n)\n        for x, nodes in enumerate(graph):\n            for y in nodes:\n                uf.union(nodes[0], y)\n                if uf.is_connected(x, y):\n                    return False\n        return True\n\n","slug":"LeetCode第785题：判断二分图","date":"2022-10-15T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,并查集","author_index":"秋水"},{"id":"d8a096fe7b0db144c234f1fea1d80896","title":"LeetCode第856题：括号的分数","content":"856.括号的分数题目信息Q\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n栈, 字符串\nYes\n\n\n题目要求给定一组n给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：\n\n() 得 1 分。\nAB 得 A + B 分，其中 A 和 B 是平衡括号字符串。\n(A) 得 2 * A 分，其中 A 是平衡括号字符串。\n\n示例示例1.\n输入： &quot;()&quot;\n输出： 1\n\n示例2.\n输入： &quot;(())&quot;\n输出： 2\n\n示例3.\n输入： &quot;()()&quot;\n输出： 2\n \n\n示例4.\n输入： &quot;(()(()))&quot;\n输出： 6\n\n解题思路\n由于这种类似与用字符串实现加减乘除的模板，那就很容易想到使用栈来解决\n其次看给出的限定条件，可以知道条件1，条件2是最简单的条件，条件1就直接赋值为1，条件2就直接使用+&#x3D;来计算同时也要考虑一下边界就好了\n条件三如果一个一个情况考虑那就太复杂了，可以使用位运算，定义一个深度的变量，深度多深就左移多少位，刚刚好实现了乘2\n\n代码参考class Solution:\n    def scoreOfParentheses(self, s: str) -&gt; int:\n        res, deep &#x3D; 0, 0\n        for i, v in enumerate(s):\n            deep +&#x3D; 1 if v &#x3D;&#x3D; &#39;(&#39; else -1\n            if v &#x3D;&#x3D; &#39;)&#39; and s[i-1] &#x3D;&#x3D; &#39;(&#39;:\n                res +&#x3D; 1 &lt;&lt; deep\n        return res\n\n","slug":"LeetCode第856题：括号的分数","date":"2022-10-15T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,栈,Like,字符串","author_index":"秋水"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"NOTHING!!(后续跟新print(&quot;hello world&quot;)\n","slug":"hello-world","date":"2022-10-15T02:41:39.690Z","categories_index":"","tags_index":"","author_index":"秋水"},{"id":"3f9b149edda744a0462c85c999c4b231","title":"LeetCode第1441题：用栈操作构建数组","content":"1441.用栈操作构建数组题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n栈,模拟\nNo\n\n\n题目要求给你一个数组 target 和一个整数 n。每次迭代，需要从  list = [1, 2, 3,..., n]中依次读取一个数字。请使用下述操作来构建目标数组 target ：\n\n&quot;Push&quot;：从 list 中读取一个新元素， 并将其推入数组中。\n&quot;Pop&quot;：删除数组中的最后一个元素。\n如果目标数组构建完成，就停止读取更多元素。\n\n题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。请返回构建目标数组所用的操作序列。如果存在多个可行方案，返回任一即可。\n示例示例1.\n输入：target = [1,3], n = 3\n输出：[&quot;Push&quot;,&quot;Push&quot;,&quot;Pop&quot;,&quot;Push&quot;]\n解释： \n读取 1 并自动推入数组 -&gt; [1]\n读取 2 并自动推入数组，然后删除它 -&gt; [1]\n读取 3 并自动推入数组 -&gt; [1,3]\n\n示例2.\n输入：target = [1,2,3], n = 3\n输出：[&quot;Push&quot;,&quot;Push&quot;,&quot;Push&quot;]\n\n示例3.\n**输入：**target = [1,2], n = 4\n**输出：**[&quot;Push&quot;,&quot;Push&quot;]\n**解释：**只需要读取前 2 个数字就可以停止。\n\n解题思路\n将target以字典形式存储，减少查找时间\n如果1-n中含target只需入栈“Push”即可，若不存在则先入“Push”再入“Pop”\n最后若max(target) &lt; n的话只用判断到target最大的值即可终止循环\n\n代码参考class Solution:\n\tdef buildArray(self, target: List[int], n: int) -&gt; List[str]:\n\t\ttar &#x3D; set(target)\n\t\tres &#x3D; []\n\t\tfor i in range(1, max(tar) + 1):\n\t\t\tres.append(&#39;Push&#39;)\n\t\t\tif i in tar:\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tres.append(&#39;Pop&#39;)\n\t\treturn res\n\n","slug":"LeetCode第1441题：用栈操作构建数组","date":"2022-10-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,栈,模拟","author_index":"秋水"},{"id":"c0524bc960f43aa892c6edbb08789fd2","title":"LeetCode第107题：二叉树的层序遍历 II","content":"107.二叉树的层序遍历 II题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n树,BFS\nYes\n\n\n题目要求给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）。\n示例示例1.\n输入：root = [3,9,20,null,null,15,7]\n输出：[[15,7],[9,20],[3]]\n\n解题思路\n利用树的BFS模板，得到结果列表反转即可\n\n代码参考class Solution:\n    def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]:\n        if not root:\n            return []\n        temp_res &#x3D; [root]\n        res &#x3D; []\n        while temp_res:\n            res.append([i.val for i in temp_res])\n            next_level &#x3D; []\n            for i in temp_res:\n                if i.left:\n                    next_level.append(i.left)\n                if i.right:\n                    next_level.append(i.right)\n            temp_res &#x3D; next_level\n\t\t# 以上为树的广度搜索的模板\n        res.reverse()\n        return res\n\n","slug":"LeetCode第107题：二叉树的层序遍历 II","date":"2022-10-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,树,BFS,Like","author_index":"秋水"},{"id":"91986e7de18a1f0d056c15eb6d3ad084","title":"LeetCode第575题：分糖果","content":"575.分糖果题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEesy\n脑筋急转弯\nNo\n\n\n题目要求 Alice 有 n 枚糖，其中第 i 枚糖的类型为 candyType[i] 。Alice 注意到她的体重正在增长，所以前去拜访了一位医生。\n医生建议 Alice 要少摄入糖分，只吃掉她所有糖的 n / 2 即可（n 是一个偶数）。Alice 非常喜欢这些糖，她想要在遵循医生建议的情况下，尽可能吃到最多不同种类的糖。\n给你一个长度为 n 的整数数组 candyType ，返回： Alice 在仅吃掉 n / 2 枚糖的情况下，可以吃到糖的最多种类数。\n示例示例1.\n输入：candyType = [1,1,2,2,3,3]\n输出：3\n解释：Alice 只能吃 6 / 2 = 3 枚糖，由于只有 3 种糖，她可以每种吃一枚。\n\n示例2.\n输入：candyType = [1,1,2,3]\n输出：2\n解释：Alice 只能吃 4 / 2 = 2 枚糖，不管她选择吃的种类是 [1,2]、[1,3] 还是 [2,3]，她只能吃到两种不同类的糖。\n\n示例3.\n输入：candyType = [6,6,6,6]\n输出：1\n解释：Alice 只能吃 4 / 2 = 2 枚糖，尽管她能吃 2 枚，但只能吃到 1 种糖。\n\n解题思路\n只需考虑两张极端思路即可得出答案\nAlice最多能吃len(candyType)的一半或者元素都相同则怎么吃都是一种\n最后只需判断是是candyType的长度一半大还是candyType的字典长度大即可\n\n代码参考class Solution:\n    def distributeCandies(self, candyType: List[int]) -&gt; int:\n        return len(candyType) &#x2F;&#x2F; 2 if len(set(candyType)) &gt; len(candyType) &#x2F;&#x2F; 2 else len(set(candyType))\n\n","slug":"LeetCode第575题：分糖果","date":"2022-10-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,脑筋急转弯","author_index":"秋水"},{"id":"21e1d52c3b2ce6bf6d44dddedefce323","title":"LeetCode第61题：旋转链表","content":"61.旋转链表题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nMed\n链表\nYes\n\n\n题目要求给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\n示例示例1.\n输入：head = [1,2,3,4,5], k = 2\n输出：[4,5,1,2,3]\n\n示例2.\n输入：head = [0,1,2], k = 4\n输出：[2,0,1]\n\n解题思路\n这种旋转的思路都大致相同，将两个相同的链表连接，然后再减去多余步数，即使答案\n例如示例二可变为：0-&gt;1-&gt;2-&gt;0-&gt;1-&gt;2，然后4是大于自身3的长度即用k去取余长度即使真正的步数，真正的步数永远不会大于两倍的lenght，所以只要在遍历一遍然后用长度减去真正的步数即使答案所求链表\n\n代码参考# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val&#x3D;0, next&#x3D;None):\n#         self.val &#x3D; val\n#         self.next &#x3D; next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:\n        if not head or not head.next or k &#x3D;&#x3D; 0:\n            return head\n        node &#x3D; ListNode(0)\n        node.next &#x3D; head\n        p1 &#x3D; node\n        lenght &#x3D; 0\n        while p1.next:\n            lenght +&#x3D; 1\n            p1 &#x3D; p1.next\n        if k % lenght &#x3D;&#x3D; 0:\n            return head\n        p1.next &#x3D; head\n        p1 &#x3D; node\n        i &#x3D; lenght - (k % lenght)\n        while i:\n            p1 &#x3D; p1.next\n            i -&#x3D; 1\n        result &#x3D; ListNode(0)\n        result.next &#x3D; p1.next\n        p1.next &#x3D; None\n        return result.next\n\n","slug":"LeetCode第61题：旋转链表","date":"2022-10-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,Like,链表","author_index":"秋水"},{"id":"2e71333626c3011cee190883801aa78f","title":"LeetCode第237题：删除链表中的节点","content":"237.删除链表中的节点题目信息\n\n\n种类\n难度\n标签\n喜欢\n\n\n\n算法\nEasy\n链表\nNo\n\n\n题目要求请编写一个函数，用于 删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问 要被删除的节点 。\n题目数据保证需要删除的节点 不是末尾节点 。\n示例示例1.\n输入：head = [4,5,1,9], node = 5\n输出：[4,1,9]\n解释：指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9\n\n示例2.\n输入：head = [4,5,1,9], node = 1\n输出：[4,5,9]\n解释：指定链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9\n\n解题思路\n由于我们不无法获取链表的头，所以编写函数需返回任何值\n我们无法获取头，也就是说我们无法对要删除的链表的前驱进行操作\n我们只需要将要删除的节点的后继的值覆盖删除节点的值\n然后将链表的倒数二个节点的后继置空，就完成了删除节点的操作\n\n代码参考#\n# @lc app&#x3D;leetcode.cn id&#x3D;237 lang&#x3D;python3\n#\n# [237] 删除链表中的节点\n#\n\n# @lc code&#x3D;start\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val &#x3D; x\n#         self.next &#x3D; None\n\nclass Solution:\n\tdef deleteNode(self, node):\n\t\t&quot;&quot;&quot;\n\t\t:type node: ListNode\n\t\t:rtype: void Do not return anything, modify node in-place instead.\n\t\t&quot;&quot;&quot;\n\t\tnode1 &#x3D; node\n\t\twhile node.next:\n\t\t\tnode.val &#x3D; node.next.val\n\t\t\tif node.next.next:\n\t\t\t\tnode &#x3D; node.next\n\t\t\telse:\n\t\t\t\tnode.next &#x3D; None\n# @lc code&#x3D;end\n\n","slug":"LeetCode第237题：删除链表中的节点","date":"2022-10-14T16:00:00.000Z","categories_index":"算法","tags_index":"力扣,链表","author_index":"秋水"}]